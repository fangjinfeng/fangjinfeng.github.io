[{"title":"Runtime (整理笔记)","date":"2017-01-21T16:00:00.000Z","path":"2017/01/22/Runtime(整理笔记)/","text":"说明:此文是自己的总结笔记，主要参考这几篇文章:iOS开发-Runtime详解NSHipster里面的这两篇文章 :Associated ObjectsMethod Swizzling 一.Runtime简介 Runtime又叫运行时，是一套底层的C语言API,其为IOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。比如: [receiver doSomething];底层运行会被编译器转化为:objc_msgSend(receiver, @selector(doSomething))如果带有参数比如:[receiver doSomething:(id)arg…];底层运行时会被编译器转化为:objc_msgSend(receiver, @selector(doSomething), arg1, arg2, …)可能通过以上你看不出它的价值，但是我们需要了解OC是一门动态语言，它会将一些工作放在代码运行时才处理而非在编译的时候，也就是说，有很多类和成员变量在我们编译的时候是不知道的，而在运行时，我们所编写的代码会转换成完整的代码运行。因此，编译器是不够，我们还需要一个运行时的系统来处理编译后的代码 Runtime 基本是C和汇编写的，可以充分保证动态系统的高效性 二. Runtime的作用: 获取某个类的所有成员变量 获取某个类的所有属性 获取某个类的所有方法 交换方法实现 动态添加一个成员变量 动态添加一个方法 三.Runtime的术语的数据结构1.SEL 它是selector在objc中的表示(Swift 中是 Selector类)。selector 是方法选择器，其实作用是对方法名进行包装，一遍找到对应的方法实现(注意:Objc 在相同的类中不会有命名相同的两个方法)。 对应的数据结构:typedef struct objc_selector *SEL;我们可以看出它是个映射到方法的C字符串，你可以通过Objc编译器命令@selector()或者Runtime系统的sel_registerName函数来获取一个SEL类型的方法选择器。 注意:不同类中相同名字的方法所对应的selector是相同的，由于变量的类型不同(即实例变量所对应的类的类型不同如NSString、NSMutableString等类型不同)，所以不会导致它们调用方法实现的混乱。 2.idid 是一个参数类型，它是指向某个类的实例的指针。定义如下: 12typedef struct objc_object *id;struct objc_object &#123; Class isa; &#125;; 通过以上定义，可以看到:objc_object结构体包含一个isa指针，根据isa指针就可以找到对象所属的类。 注意:isa指针在代码运行时并不总是指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型需要用对象的 - class方法。 3.Class typedef struct objc_class *Class;Class 其实是指向 objc_class 结构体的指针。objc_class的数据结构如下: 1234567891011121314151617struct objc_class &#123;Class isa;//指针，顾名思义，表示是一个什么，//实例的isa指向类对象，类对象的isa指向元类#if !__OBJC2__Class super_class; //指向父类const char *name; //类名long version; // 类的版本信息，初始化默认为0，可以通过runtime函数class_setVersion和class_getVersion进行修改、读取long info; // 一些标识信息,如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;long instance_size; // 该类的实例变量大小(包括从父类继承下来的实例变量);struct objc_ivar_list *ivars // 成员变量列表struct objc_method_list **methodLists; // 方法列表struct objc_cache *cache;// 缓存,存储最近使用的方法指针，用于提升效率struct objc_protocol_list *protocols // 协议列表#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 从结构体可以看出，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。其中objc_ivar_list和objc_method_list 分别是成员变量列表和方法列表: 123456789101112131415161718192021// 成员变量列表struct objc_ivar_list &#123;int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;// 方法列表struct objc_method_list &#123;struct objc_method_list *obsolete OBJC2_UNAVAILABLE;int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 我们都知道，OC中一切都被设计成对象，一个类被初始化成一个实例，这个实例是一个对象。实际上一个类的本质也是一个对象，在runtime中用如上结构体表示。关于isa指针: 比如 : NSString *tmpStr = [NSString string];这里的tmpStr的isa指针指向类对象NSString,而NSString的isa指针指向元类NSObject. 4. MethodMethod 代表类中某个方法的类型 1234567typedef struct objc_method *Method;struct objc_method &#123;SEL method_name OBJC2_UNAVAILABLE;char *method_types OBJC2_UNAVAILABLE;IMP method_imp OBJC2_UNAVAILABLE;&#125; objc_method存储了方法名、方法类型和方法实现: 方法名类型为SEL 方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型 method_imp 指向了方法的实现，本质是一个函数指针 5.IvarIvar 是成员变量的类型。 1234567891011typedef struct objc_ivar *Ivar;struct objc_ivar &#123;char *ivar_name // 变量名称;char *ivar_type // 变量类型;int ivar_offset // 基地址偏移字节;#ifdef __LP64__int space // 大小;#endif&#125;其中 ivar_offset 是基地址偏移字节 6.IMPIMP在objc.h中的定义是:typedef id (*IMP)(id, SEL, …);它是一个函数指针，这是由编译器生成的。当你发送一个objc消息之后，最终它会执行那段代码，就是由这个函数指针指定的。而IMP这个函数指针就指向了这个方法的实现。 我们发现IMP指向的方法和objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的实现方法地址。所以一个确定的方法也只有一组id和SEL参数:比如: 12NSString *tmpStr = [NSString string];BOOL isContain = [tmpStr containsString:@\"1\"]; 这里的containsString的实现方法就是由id(NSString)和SEL参数(containsString)确定的。 7.Cache 1234567typedef struct objc_cache *Cachestruct objc_cache &#123;unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE;unsigned int occupied OBJC2_UNAVAILABLE;Method buckets[1] OBJC2_UNAVAILABLE;&#125;; Cache主要用来提高查找效率，当一个方法被调用，首先在Cache列表中查找，如果找到直接返回，如果没有找到，再到类的方法列表去查找，找到了将该方法返回同时存入缓存列表。 8.Property 12typedef struct objc_property *Property;typedef struct objc_property *objc_property_t;//这个更常用 可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性： 12objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount) 注意返回的是属性列表，列表中的每个元素都是一个objc_property_t指针 总结: 1234567891011121314151617// 描述类中的一个方法typedef struct objc_method *Method;// 实例变量typedef struct objc_ivar *Ivar;// 缓存(类方法)typedef struct objc_cache *Cache；// 实现 方法typedef id (*IMP)(id, SEL, ...);// 类别Categorytypedef struct objc_category *Category;// 类中声明的属性typedef struct objc_property *objc_property_t; 四.获取列表有时候会有这样的需求，我们需要知道当前类中每个属性的名字(比如字典转模型，字典的key和模型对象的属性名字不匹配)。我们可以通过runtime的一系列方法获取类的一些信息(包括属性列表、方法列表、成员变量列表和遵循的协议列表) 1234567unsigned int count;//获取属性列表objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);for (unsigned int i=0; i&lt;count; i++) &#123;const char *propertyName = property_getName(propertyList[i]);NSLog(@\"property----&gt;%@\", [NSString stringWithUTF8String:propertyName]);&#125; 123456//获取方法列表Method *methodList = class_copyMethodList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) &#123;Method method = methodList[i];NSLog(@\"method----&gt;%@\", NSStringFromSelector(method_getName(method)));&#125; 1234567//获取成员变量列表Ivar *ivarList = class_copyIvarList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) &#123;Ivar myIvar = ivarList[i];const char *ivarName = ivar_getName(myIvar);NSLog(@\"Ivar----&gt;%@\", [NSString stringWithUTF8String:ivarName]);&#125; 1234567//获取协议列表__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) &#123;Protocol *myProtocal = protocolList[i];const char *protocolName = protocol_getName(myProtocal);NSLog(@\"protocol----&gt;%@\", [NSString stringWithUTF8String:protocolName]);&#125; 五.方法调用方法调用在运行时的过程: 如果调用的是类方法，就会到类对象的isa指针指向的对象(也就是元类对象)中操作。比如:NSString *tmpStr = [NSString string];这里的 [NSString string]调用的是NSString的类方法，就会到NSString类对象的isa指针指向的对象NSObject元类中操作。 如果用实例对象调用实例方法，会到实例的isa指针指向的对象(也就是类对象)操作。比如: BOOL isContain = [tmpStr containsString:@”1”];这里的 [tmpStr containsString:@”1”],就是实例对象tmpStr调用containsString这个实例方法，得到实例tmpStr的isa指针指向的对象也就是类对象NSString操作。 NSString *tmpStr = [NSString string];BOOL isContain = [tmpStr containsString:@”1”]; 1. 首先，在相应操作对象中的缓存列表中查找调用的方法，如果找到，转向相应的实现并执行.(即先在tmpStr这个对象的缓存列表中查找是否有containsString这个方法，如果有，则转向相应的实现函数，并执行)； 2.如果没有找到，在相应操作对象的方法中找调用的方法，如果找到，转向相应的实现并执行。(即tmpStr的缓存列表找没有找到containsString这个方法，就到tmpStr的方法列表里面查找，如果找到，则转向相应的实现函数，并执行)； 3.如果没找到，去父类指针所指向的对象中执行1，2（即如果在tmpStr的方法列表里面没有找到containsString这个方法，则转向tmpStr的父类，也就是NSObject类去查找该方法） 4.以此类推，如果一直到根类都还没找到，转向拦截调用(即如果在父类NSObject里面也没有找到containsString这个方法，就往上一层父类再去查找，知道最顶层(根层)父类，因为NSObject在OC中是根层父类，所以如果在NSObjec的方法列表找没找到containsString，就转向拦截调用) 5.如果没有重写拦截调用的方法，程序报错。(即在tmpStr及其父类的方法列表中都没有containsString这个方法，就转向拦截调用，但是却没有实现拦截调用的方法，系统就报错) 所以: 重写父类的方法，并没有覆盖父类的方法，只是在当前类对象中找到了这个方法后，就不会再去父类中寻找了。 如果子类重写父类的方法，但也想调用父类方法的实现，只需使用super这个编译器标识，它会在运行时先去调用父类的方法，在执行之类的方法。比如我们很常见的viewWillAppear函数: 1234- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];[self.navigationController setNavigationBarHidden:YES animated:animated];&#125; 这里的super标识，在运行时会先去执行父类的viewWillAppear方法，执行完毕之后，在回来接着执行原函数里面的隐藏导航栏的操作，如果没有 [super viewWillAppear:animated];就不会去调用父类的该方法，直接执行隐藏导航栏的操作。 六.拦截调用拦截调用就是在找不到调用方法程序崩溃之前，你有机会通过重写NSObject的四个方法来处理，防止崩溃发生。 (BOOL)resolveClassMethod:(SEL)sel;该方法就是当你调用一个不存在的类方法的时候，会调用该方法，默认返回NO,你可以加上自己的处理然后返回YES. (BOOL)resolveInstanceMethod:(SEL)sel;这个方法和上一个方法相似，处理的是实例方法。(备注: NSString *tmpStr = [NSString string];像 [NSString string]这里的string就是类方法， [tmpStr containsString:@”1”]这里的containsString就是实例方法。) (id)forwardingTargetForSelector:(SEL)aSelector;该方法将你调用的不存在的方法重定向到一个声明了这个方法的类，只需要你返回一个有这个方法的target. (void)forwardInvocation:(NSInvocation *)anInvocation;该方法将你调用的不存在的方法打包成NSInvocation传给你。做完你自己的处理后，调用inovkeWithTarget:方法让某个target触发这个方法。 七.动态添加方法重写了拦截调用的方法并且返回YES,接下来可以根据传入的SEL类型的selector，动态添加一个方法。 首先从外部隐式调用一个不存在的方法: 1234567// 隐式调用方法[target performSelector:@selector(resolveAdd:) withObject:@\"test\"];然后，在target对象内部重写拦截调用的方法，动态添加方法void runAddMethod(id self, SEL _cmd, NSString *string)&#123;NSLog(@\"add C IMP \", string);&#125; 1234567+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;//给本类动态添加一个方法if ([NSStringFromSelector(sel) isEqualToString:@\"resolveAdd:\"]) &#123;class_addMethod(self, sel, (IMP)runAddMethod, \"v@:*\");&#125;return YES;&#125; 其中class_addMethod的四个参数分别是: Class cls 给哪个类添加方法，本例中是self SEL name 添加的方法，本例中是重写拦截调用传进来的selector IMP imp 方法的实现，C方法的实现可以直接获得。如果是OC方法，可以用+(IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。 “v@:*”方法的签名，代表有一个参数的方法 八.关联对象比如现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。这种情况的一般解决办法就是继承。但是，只增加一个属性，就去继承一个类，总结太麻烦，这时候runtime的关联属性就发挥它的作用了。 1.首先定义一个全局变量，用它的地址作为关联对象的key static char kAssociatedObjectKey;2.在NSObject+AssociatedObject.h里面添加新的属性 12345NSObject+AssociatedObject.h@interface NSObject (AssociatedObject) @property (nonatomic, strong) id associatedObject; @end 3.在NSObject+AssociatedObject.m里面添加设置和获取方法 1234567891011121314//设置关联对象@implementation NSObject (AssociatedObject) @dynamic associatedObject; - (void)setAssociatedObject:(id)object &#123; objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; //获取关联对象- (id)associatedObject &#123; return objc_getAssociatedObject(self, @selector(associatedObject)); &#125; objc_setAssociatedObject的四个参数: id object 给谁设置关联对象 const void *key 关联对象唯一的key,获取时会用到 id value 关联的对象 objc_AssociationPolicy 关联策略,有以下几种策略: 1234567enum &#123;OBJC_ASSOCIATION_ASSIGN = 0, // 给关联对象指定弱引用OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 给关联的对象指定非原子操作哦OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 给关联对象指定费原子的copy特性OBJC_ASSOCIATION_RETAIN = 01401, // 给关联的对象指定原子的强引用OBJC_ASSOCIATION_COPY = 01403 // 给关联的对象指定原子的copy 特性&#125;; objc_getAssociatedObject 的两个参数: id object 获取谁的关联对象 const void *key 根据这个唯一的key获取关联对象。 其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能类的类别里面，方便调用。 12345678//添加关联对象- (void)addAssociatedObject:(id)object&#123;objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;//获取关联对象- (id)getAssociatedObject&#123;return objc_getAssociatedObject(self, _cmd);&#125; getAssociatedObject 方法的地址作为唯一的key， _cmd代表当前调用方法的地址，也就是getAssociatedObject方法的地址 注意 :4.移除关联对象:objc_removeAssociatedObjects()这个函数很容易让对象恢复成它”原始状态”，你不应该使用它来移除关联的对象，因为它也会移除包括其他地方加入的全部关联对象。所以你一般只需要通过调用objc_setAssociatedObject并传入nil值类清除关联值。 优秀样例 添加私有属性用于更好地去实现细节。当扩展一个内建类的行为时，保持附加属性的状态可能非常必要。注意以下说的是一种非常教科书式的关联对象的用例：AFNetworking在 UIImageView的category上用了关联对象来保持一个operation对象，用于从网络上某URL异步地获取一张图片。 添加public属性来增强category的功能。有些情况下这种(通过关联对象)让category行为更灵活的做法比在用一个带变量的方法来实现更有意义。在这些情况下，可以用关联对象实现一个一个对外开放的属性。回到上个AFNetworking的例子中的 UIImageViewcategory，它的 imageResponseSerializer方法允许图片通过一个滤镜来显示、或在缓存到硬盘之前改变图片的内容。 创建一个用于KVO的关联观察者。当在一个category的实现中使用KVO时，建议用一个自定义的关联对象而不是该对象本身作观察者。 错误模式 在不必要的时候使用关联对象。使用视图时一个常见的情况是通过数据模型或一些复合的值来创建一个便利的方法设置填充字段或属性。如果这些值在后面不会再被使用到，最好就不要使用关联对象了。(比如你将自定义的UITableViewCell跟模型关联起来，但这个cell值用在一个ViewController里面，也就是说这个关联对象只用到一处，之后就不再使用，这种情况下就没必要使用关联对象)。 使用关联对象来保存一个可以被推算出来的值。例如，有人可能想通过关联对象存储UITableViewCell上一个自定义accessoryView的引用，使用tableView:accessoryButtonTappedForRowWithIndexPath: 和 cellForRowAtIndexPath:即可以达到要求。 使用关联对象来代替X。其中X代表下面的一些项：子类化，当使用继承比使用组合更合适的时候。 Target-Action给响应者添加交互事件。 手势识别，当target-action模式不够用的时候。 代理，当事件可以委托给其他对象。 消息 &amp; 消息中心使用低耦合的方式来广播消息。 九.方法交换顾名思义:就是将两个方法的实现交换，比如，将A方法和B方法交换，调用A方法的时候，就回去执行B方法中的代码，反之亦然。参考Mattt Thompson的[Method Swizzling]文章: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;Class class = [self class];SEL originalSelector = @selector(viewWillAppear:);SEL swizzledSelector = @selector(xxx_viewWillAppear:);Method originalMethod = class_getInstanceMethod(class, originalSelector);Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);// When swizzling a class method, use the following:// Class class = object_getClass((id)self);// ...// Method originalMethod = class_getClassMethod(class, originalSelector);// Method swizzledMethod = class_getClassMethod(class, swizzledSelector);BOOL didAddMethod =class_addMethod(class,originalSelector,method_getImplementation(swizzledMethod),method_getTypeEncoding(swizzledMethod));if (didAddMethod) &#123;class_replaceMethod(class,swizzledSelector,method_getImplementation(originalMethod),method_getTypeEncoding(originalMethod));&#125; else &#123;method_exchangeImplementations(originalMethod, swizzledMethod);&#125;&#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123;[self xxx_viewWillAppear:animated];NSLog(@\"viewWillAppear: %@\", self);&#125; @end在自己定义的viewController中重写viewWillAppear 1234- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];NSLog(@\"viewWillAppear\");&#125; 就会调用xxx_viewWillAppear,输出log, method swizzling在视图控制器的生命周期、响应事件、绘制视图或者Foundation框架的网络栈等方法中需要插入代码的时候，都是很好的解决方法。 +load vs +initialize: swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。 +load 是在一个类被初始装载时调用(iOS应用启动的时候，就会加载所有的类，就会调用这个方法)；并且因为加载进内存只会加载一次，所以也一般也只会调用一次 +initialize 是在应用第一次调用该类的类方法或实例方法前调用的，调用次数根据子类和具体调用情况确定。 dispatch_once: swizzling 应该只在 dispatch_once 中完成。 由于 swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 满足了所需要的需求，并且应该被当做使用 swizzling 的初始化单例方法的标准。 Selectors, Methods, &amp; Implementations苹果定义: Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。 Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。 Implementation（typedef id (*IMP)(id, SEL,…)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象metaclass）。第二个参数是这个方法的名字selector，该方法的真正参数紧随其后。 三者之间的关系: 在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。 也就是说swizzling只是交换两个方法在函数表中的指向地址而已。 调用 _cmd 1234- (void)xxx_viewWillAppear:(BOOL)animated &#123;[self xxx_viewWillAppear:animated];NSLog(@\"viewWillAppear: %@\", NSStringFromClass([self class]));&#125; 初看这段代码，我们都会觉得会出现递归死循环。但事实不是这样的: method swizzling 在交换方法的实现后，xxx_viewWillAppear:方法的实现已经被替换为UIViewController 的-viewWillAppear：这个原生方法。 所以当我们在UIViewController调用这个- (void)viewWillAppear:(BOOL)animated 方法的时候，实际上调用的是xxx_viewWillAppear这个方法，而 [self xxx_viewWillAppear:animated];这个方法实际上调用的是系统的viewWillAppear。 这就证实了swizzling只是交换两个方法在函数表中的指向地址而已。 预防措施 在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。 避免冲突：为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。 理解实现原理： 只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 能够让你更好理解实现原理。 持续的预防： 不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。 1. 常见坑 Method swizzling 是非原子性的，在多线程环境下可能被多次修改，但同样 Method swizzling 又是全局性的，就会造成不可预知的错误。 可能出现命名冲突的问题，这样就不会调用到系统原方法，可能导致未知问题。 Method swizzling 看起来像递归，对新人来说不容易理解。 出现问题 Method swizzling 不容易进行debug，来发现问题 随着项目迭代和人员更换，使用Method swizzling 的项目不容易维护，因为开发人员有时根本不知道在Method swizzling 里面修改了东西。 十.感想runtime是把双刃剑，因为所有的代码都运行在它之上，改变它，可能会改变代码的正常运行逻辑和所有与之交互的东西，因此会产生可怕的副作用。但同时它强大的功能也可以给应用的框架或者代码的编写带来非常大的遍历。 因此，对于runtime唯一的建议就是，需谨慎使用，一旦使用，必须先了解runtime的相关原理，做好预防措施。 十一.最后:送上一张喜欢的图片: 提醒:不应该把runtime的使用看成是高大上的东西，并以使用这个为荣，实际开发中runtime能少用应该少用，正常的系统方法才是正道！ 这是一篇总结笔记，大家有兴趣可以蛮看一下，这里是简书链接如果觉得不错，麻烦给个喜欢或star,若发现有错误的地方请及时反馈，谢谢！","tags":[{"name":"IOS","slug":"IOS","permalink":"//fjf.com/tags/IOS/"},{"name":"Runtime","slug":"Runtime","permalink":"//fjf.com/tags/Runtime/"},{"name":"黑魔法","slug":"黑魔法","permalink":"//fjf.com/tags/黑魔法/"},{"name":"Associated Objects","slug":"Associated-Objects","permalink":"//fjf.com/tags/Associated-Objects/"},{"name":"Method Swizzling","slug":"Method-Swizzling","permalink":"//fjf.com/tags/Method-Swizzling/"}]},{"title":"FJImageBrowser图片浏览器","date":"2017-01-16T06:00:37.000Z","path":"2017/01/16/FJImageBrowser图片浏览器/","text":"一.框架介绍由于项目需求，然后也没有找到完全合适的第三方，所以自己写了一个图片浏览器，后来公司几个项目都用到了这个图片浏览器，为了适应各种产品需求，较之前添加了些功能,主要支持: 1.支持模仿微博的直接动画放大功能;2.支持模仿微信的当下载中的时候，居中显示，下载完成放大，如果已经下载,直接动画放大。3.支持本地图片和网络图片的混搭，比如说聊天页面有自己发送的本地图片和别人发过来的网络图片，这个框架会自动判断。4.支持图片复用，一次只加载三张图片，优化内存 5.支持长图、动态图、下载进度显示 二.效果图当时项目需求如图所示，由于大部分第三方回去的时候会存在抖动问题，所以当时自己简单写了个浏览器，后来其他项目也用到了，所以做了扩展和优化,进行了图片复用，一次只加载三张图片，优化了内存，同时支持长图和动态图,以及进度下载进度显示。 1.UIScrollView 效果图: UIScrollView_example 2.UICollectionView 模仿微博模式 效果图: UICollectionView_微博模式 3.UICollectionView 模仿微信模式 效果图: UICollectionView_微信模式 二.实现方法1.创建FJPhotosView实例 123456789FJPhotosView *photosView = [[FJPhotosView alloc] init];// self.imageArray: 大图url数组 // selectedIndex: 当前选中图片索引 // photoViewShowType: 显示模式 [photosView setParam:self.bigImageArray selectedIndex:indexPath.row photoViewShowType:self.switchShowBtn.selected];// 设置代理 photosView.delegate = self;// 展示图片浏览器[photosView show]; 其中: 1234567// 显示 模式typedef NS_ENUM(NSInteger, PhotoViewShowType)&#123; // 模仿微博显示 PhotoViewShowTypeOfWeiBo = 0, // 模仿微信显示 PhotoViewShowTypeOfWeiXin = 1,&#125;; 2.实现代理方法 – FJPhotosViewDelegate 1234567891011// 返回临时占位图片（即原来的小图）- (UIImageView *)photoBrowser:(FJPhotosView *)browser placeholderImageForIndex:(NSInteger)index &#123; //获取占位小图代码；&#125; // 返回临时占位图片位置-(CGRect)photoBrowser:(FJPhotosView *)browser targetRectForIndex:(NSInteger)index &#123;//获取占位图片位置代码；&#125; 三.代码解析1.架构解析A.FJPhotosView: a.FJPhotosView图片浏览器入口，加载在[UIApplication sharedApplication].keyWindow上，这样可以有效的避免消失时的抖动情况。 1234567891011- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; self.backgroundColor = [UIColor blackColor]; self.frame = [UIApplication sharedApplication].keyWindow.bounds; [[UIApplication sharedApplication].keyWindow addSubview:self]; &#125; return self;&#125; b.FJPhotosView拥有一个最外围UIScrollView负责容纳显示视图和一个UILabel负责显示当前序号,然后根据传入的参数进行初始化 主要参数: 1234567891011// titleLabel :展示当前页数和总页数@property (nonatomic, strong) UILabel *titleLabel;// UIScrollView: 加载3张展示的视图@property (nonatomic, strong) UIScrollView *scrollView;// photoView array （FJPhotoScrollView 数组）@property (nonatomic, strong) NSMutableArray *photoViewArray;// imageurl array （imageUrl 数组）@property (nonatomic, strong) NSMutableArray *photoImageUrlArray; 主要函数: 12345678910111213//初始化PhontoView(只加载三张展示图)- (void)setupPhotoViews &#123; if (self.photoImageUrlArray.count &gt; 0) &#123; for (NSInteger i = 0; i &lt; 3; i++) &#123; FJPhotoScrollView *photoView = [[FJPhotoScrollView alloc] initWithFrame:CGRectMake(self.scrollView.width * i, 0, self.scrollView.width, self.scrollView.height)]; photoView.delegate = self; photoView.parentPhotosView = self; [self.scrollView addSubview:photoView]; [self.photoViewArray addObject:photoView]; &#125; [self setupAvailalbePhotoView]; &#125; &#125; 根据点击的selectIndex加载前后的两张视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 初始化 可视 photoView- (void)setupAvailalbePhotoView &#123; if (_selectedIndex &gt;= self.photoImageUrlArray.count) &#123; _selectedIndex = 0; &#125; //点击第一张 if (_selectedIndex == 0) &#123; for (NSInteger tmpIndex = 0; tmpIndex &lt; 3; tmpIndex++) &#123; if (tmpIndex &gt;= self.photoImageUrlArray.count) &#123; break; &#125; if (tmpIndex == 0) &#123; _transferPhotoView = [self.photoViewArray objectAtIndex:tmpIndex]; &#125; [self configContentWithPage:tmpIndex photoView:[self.photoViewArray objectAtIndex:tmpIndex]]; &#125; &#125; else if (_selectedIndex == (self.photoImageUrlArray.count - 1)) &#123;//点击最后一张 NSInteger tempIndex = 0; for (NSInteger index = (self.photoImageUrlArray.count - 1);index &gt;= (self.photoImageUrlArray.count - 3); index--) &#123; if (index &lt; 0) &#123; continue; &#125; if (index == _selectedIndex) &#123; _transferPhotoView = [self.photoViewArray objectAtIndex:tempIndex]; &#125; [self configContentWithPage:index photoView:[self.photoViewArray objectAtIndex:tempIndex++]]; &#125; &#125; //点击中间图片 else &#123; if (self.photoViewArray.count &gt; 2) &#123; _transferPhotoView = [self.photoViewArray objectAtIndex:1]; //先加载中间 [self configContentWithPage:_selectedIndex photoView:[self.photoViewArray objectAtIndex:1]]; [self configContentWithPage:_selectedIndex - 1 photoView:[self.photoViewArray objectAtIndex:0]]; [self configContentWithPage:_selectedIndex + 1 photoView:[self.photoViewArray objectAtIndex:2]]; &#125; &#125; if (self.photoImageUrlArray.count &gt; 1) &#123; self.titleLabel.text = [NSString stringWithFormat:@\"%@/%ld\",@(_selectedIndex+1), (long)self.photoImageUrlArray.count]; &#125; self.scrollView.contentSize = CGSizeMake(self.photoImageUrlArray.count * FW(self.scrollView), self.scrollView.bounds.size.height); [self.scrollView scrollRectToVisible:CGRectMake(_selectedIndex * FW(self.scrollView), 0, FW(self.scrollView), FH(self.scrollView)) animated:NO];&#125; 将相应的参数传给FJPhotoScrollView,让FJPhotoScrollView进行图片的显示 1234567// 配置 相关 图片- (void)configContentWithPage:(NSInteger)page photoView:(FJPhotoScrollView*)photoView &#123; id variable = [self.photoImageUrlArray objectAtIndex:page]; [photoView setParamWithVariable:variable currentIndex:page photoViewShowType:_photoViewShowType]; photoView.frame = CGRectMake(page * FW(_scrollView), FY(photoView), FW(photoView), FH(photoView)); photoView.backgroundColor = [UIColor blackColor];&#125; 通过 UIScrollViewDelegate 进行图片的缩放 12345678910111213141516171819202122232425262728// 图片 放大 缩小- (void)scrollViewDidZoom:(FJPhotoScrollView *)photoView &#123; if (photoView == self.scrollView)&#123; return; &#125; CGSize boundsSize = self.scrollView.bounds.size; CGRect contentsFrame = photoView.myImageView.frame; if (contentsFrame.size.width &lt; boundsSize.width) &#123; contentsFrame.origin.x = (boundsSize.width - contentsFrame.size.width) / 2.0f; &#125; else &#123; contentsFrame.origin.x = 0.0f; &#125; if (contentsFrame.size.height &lt; boundsSize.height) &#123; contentsFrame.origin.y = (boundsSize.height - contentsFrame.size.height) / 2.0f; &#125; else &#123; contentsFrame.origin.y = 0.0f; &#125; photoView.myImageView.frame = contentsFrame; &#125; 图片滚动加载前后图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 图片 滚动- (void)scrollViewDidScroll:(UIScrollView *)aScrollView &#123; static NSInteger temp_lastPage = -1; CGFloat pageWidth = self.scrollView.frame.size.width; NSInteger page = floor((self.scrollView.contentOffset.x - pageWidth / 2) / pageWidth) + 1; NSInteger photoCount = [self.photoImageUrlArray count]; if (page &gt;= photoCount) &#123; return; &#125; _currentSelectIndex = page; _titleLabel.text = [NSString stringWithFormat:@\"%ld/%ld\",(long)page+1, (long)photoCount]; if (aScrollView == self.scrollView &amp;&amp; temp_lastPage!=page) &#123; if (_currShowImageIndex &gt; -1 &amp;&amp; _currShowImageIndex &lt; 3) &#123; FJPhotoScrollView *subPhotoScrollView = [self.photoViewArray objectAtIndex:_currShowImageIndex]; subPhotoScrollView.zoomScale = 1; temp_lastPage = page; &#125; &#125; if (aScrollView != self.scrollView) &#123; return; &#125; if (_lastPage != page) &#123; for (NSInteger i = 0; i&lt;[self.photoViewArray count]; i++) &#123; FJPhotoScrollView *tmpPhotoScrollView = [self.photoViewArray objectAtIndex:i]; if (FX(tmpPhotoScrollView) == page * FW(aScrollView)) &#123; _currShowImageIndex = i; break; &#125; &#125; if (page &gt; 0 &amp;&amp; page &lt; self.photoImageUrlArray.count - 1) &#123; for (NSInteger i = 0; i &lt; 3; i++) &#123; UIImageView *tmpImageView = [self.photoViewArray objectAtIndex:_currShowImageIndex]; FJPhotoScrollView *tmpPhotoScrollView = [self.photoViewArray objectAtIndex:i]; //加载下一页 if ((FX(tmpImageView) - FX(tmpPhotoScrollView)) &gt; FW(self.scrollView)) &#123; [self configContentWithPage:page + 1 photoView:tmpPhotoScrollView]; &#125; //加载上一页 else if ((FX(tmpPhotoScrollView) - FX(tmpImageView)) &gt; FW(self.scrollView)) &#123; [self configContentWithPage:page - 1 photoView:tmpPhotoScrollView]; &#125; &#125; &#125; _lastPage = page; &#125; aScrollView.userInteractionEnabled=YES;&#125; B.FJPhotoScrollView a.FJPhotoScrollView继承自FJBaseScrollView,本身是一个UIScrollView,拥有myImageView(主展示图)、originalImageView(占位小图)和progressLayer(进度条): 123456// 展示图@property(nonatomic, strong) UIImageView *myImageView;// 进度条@property (nonatomic, strong) CAShapeLayer *progressLayer;// 占位图@property (nonatomic, strong) UIImageView *originalImageView; b.FJPhotoScrollView通过设置参数函数进行图片类型判断、动画效果选择、下载进度显示。核心函数: 123456789101112131415161718192021222324252627282930313233343536373839// 设置相关参数- (void)setParamWithVariable:(id)variable currentIndex:(NSInteger)currentIndex photoViewShowType:(PhotoViewShowType)photoViewShowType &#123; //初始位置 _variable = variable; self.currentIndex = currentIndex; // 获取原图位置 CGRect originalRect = [self targetRectForIndex:currentIndex]; self.myImageView.frame = originalRect; // 获取 临时占位图 self.originalImageView = [self placeholderImageForIndex:currentIndex]; // 微博 显示 方式 (直接放大) if (photoViewShowType == PhotoViewShowTypeOfWeiBo) &#123; [self showDirectlyAmplifyPhotoViewAnimation:_variable]; &#125; // 微信 显示 方式 (加载完成后 放大) else if(photoViewShowType == PhotoViewShowTypeOfWeiXin &amp;&amp; [self isImageUrl:variable]) &#123; // 图片未下载 先显示在 中部 NSString *tmpImageUrl = (NSString *)variable; if ([self.myImageView exitCurrentImage:tmpImageUrl] == NO) &#123; [UIView animateWithDuration:FJDefaultAnimationTime animations:^&#123; [self setMyimageViewInTheMiddle:self.originalImageView]; &#125; completion:^(BOOL finished) &#123; [self showImageViewDowningProgerss:tmpImageUrl isAnimation:YES]; &#125;]; &#125; // 图片已下载 直接放大 else &#123; [self showDirectlyAmplifyPhotoViewAnimation:_variable]; &#125; &#125;&#125; variable 之所以是id类型，主要是为了做本地图片和网络图片的兼容，通过函数isImageUrl判断是否为网络图片: 12345678910// 判断 是否 为 网络 图片- (BOOL)isImageUrl:(id)variable &#123; BOOL isImageUrl = NO; // NSString 类型 if ([variable isKindOfClass:[NSString class]]) &#123; NSString *tmpStr = (NSString *)variable; isImageUrl = [tmpStr isHttpUrl]; &#125; return isImageUrl;&#125; 如果非网络图片就是本地图片，本地图片就直接动画放大显示，如果是网络图片，判断是否下载，如果未下载，判断如果是微信模式，就先居中显示，然后去下载，如果是微博模式，就直接放大下载。 123456789101112131415161718192021222324// 显示 直接 放大 图片 动画- (void)showDirectlyAmplifyPhotoViewAnimation:(id)variable &#123; [UIView animateWithDuration:FJDefaultAnimationTime animations:^&#123; [self setFrameAndZoom:self.originalImageView]; &#125; completion:^(BOOL finished) &#123; self.userInteractionEnabled = YES ; // 网络 图片 if ([self isImageUrl:variable]) &#123; [self showImageViewDowningProgerss:(NSString *)_variable isAnimation:NO]; &#125; // 本地 图片 else &#123; //变换完动画 从网络开始加载图 self.myImageView.image = [self getImage:variable]; [self setFrameAndZoom:self.myImageView];//设置最新的网络下载后的图的frame大小 &#125; &#125;];&#125; 网络图片显示下载进度，下载完成后动画展现 123456789101112131415161718192021222324252627// 显示 下载进入和 下载完成 展现 动画- (void)showImageViewDowningProgerss:(NSString *)imageUrl isAnimation:(BOOL)isAnimation&#123; //变换完动画 从网络开始加载图 NSString *imageUrlStr = [[imageUrl stringByReplacingOccurrencesOfString:@\"\\\\\" withString:@\"\"] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [self.myImageView sd_setImageWithURL:[NSURL URLWithString:imageUrlStr] placeholderImage:self.myImageView.image options:SDWebImageRetryFailed|SDWebImageLowPriority progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; if (receivedSize &gt; 0 &amp;&amp; expectedSize &gt; 0) &#123; CGFloat progress = receivedSize / (float)expectedSize; progress = progress &lt; 0.01 ? 0.01 : progress &gt; 1 ? 1 : progress; if (isnan(progress)) progress = 0; self.progressLayer.hidden = NO; self.progressLayer.strokeEnd = progress; &#125; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; self.progressLayer.hidden = YES; if (isAnimation) &#123; [UIView animateWithDuration:FJDefaultAnimationTime animations:^&#123; [self setFrameAndZoom:self.myImageView]; &#125;]; &#125; else &#123; [self setFrameAndZoom:self.myImageView]; &#125; &#125;];&#125; 微信模式未下载情况先显示在中间函数: 123456789101112131415161718192021222324252627282930313233343536// 微信 模式 还没下载完成 显示在中间- (void)setMyimageViewInTheMiddle:(UIImageView *)imageView &#123; //设置空image时的情况 //ImageView.image的大小 CGFloat imageH; CGFloat imageW; if(imageView == nil) &#123; imageH = self.myImageView.height; imageW = self.myImageView.width; self.myImageView.image = IMG(@\"default_avatar_geren_134.png\"); &#125; else &#123; imageW = imageView.width; imageH = imageView.height; if (imageW &lt; 0.5 || imageH &lt; 0.5) &#123; imageH = self.myImageView.height; imageW = self.myImageView.width; &#125; self.myImageView.image = imageView.image; &#125; if (imageW &lt; 0.5 || imageH &lt; 0.5) &#123; imageH = SCREEN_WIDTH / 2.5; imageW = SCREEN_WIDTH / 2.5; &#125; CGFloat imageX = (SCREEN_WIDTH/2.0) - (imageW/2.0); CGFloat imageY = (SCREEN_HEIGHT/2.0) - (imageH/2.0); self.myImageView.frame = CGRectMake(imageX, imageY, imageW, imageH);&#125; 下载完成后或是本地图片直接放大以及图片缩放被说计算函数: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 微博 模式 直接 放大-(void)setFrameAndZoom:(UIImageView *)imageView &#123; //ImageView.image的大小 CGFloat imageH; CGFloat imageW; //设置空image时的情况 if(imageView.image == nil || imageView.image.size.width == 0 || imageView.image.size.height == 0) &#123; //设置主图片 imageH = SCREEN_HEIGHT; imageW = SCREEN_WIDTH; self.myImageView.image = IMG(@\"default_avatar_geren_134.png\"); &#125; //不空 else&#123; //设置主图片 imageW = imageView.image.size.width; imageH = imageView.image.size.height; self.myImageView.image = imageView.image; &#125; //设置主图片Frame 与缩小比例 //横着 if(imageW &gt;= (imageH * (SCREEN_WIDTH/SCREEN_HEIGHT)))&#123; //设置居中frame CGFloat myX_ = 0; CGFloat myW_ = SCREEN_WIDTH; CGFloat myH_ = myW_ *(imageH/imageW);; CGFloat myY_ = SCREEN_HEIGHT - myH_ - ((SCREEN_HEIGHT - myH_)/2); self.myImageView.frame = CGRectMake(myX_, myY_, myW_, myH_); if (myH_ &gt; SCREEN_HEIGHT) &#123; self.contentSize = CGSizeMake(SCREEN_WIDTH, myH_); &#125; //判断原图是小图还是大图来判断,是可以缩放,还是可以放大 if (imageW &gt; myW_) &#123; self.maximumZoomScale = 3*(imageW/myW_ ) ;//放大比例 &#125; else&#123; self.minimumZoomScale = (imageW/myW_);//缩小比例 &#125; &#125; //竖着 else &#123; CGFloat myX_ = 0; CGFloat myY_ = 0; CGFloat myW_ = SCREEN_WIDTH; CGFloat myH_ = floor(imageH / (imageW / self.width)); if (myH_ &gt; SCREEN_HEIGHT) &#123; self.contentSize = CGSizeMake(SCREEN_WIDTH, myH_); &#125; //变换设置frame self.myImageView.frame = CGRectMake(myX_, myY_, myW_, myH_); //判断原图是小图还是大图来判断,是可以缩放,还是可以放大 if (imageH &gt; myH_) &#123; self.maximumZoomScale = 3*(imageH/myH_ ) ;//放大比例 &#125; else &#123; self.minimumZoomScale = (imageH/myH_);//缩小比例 &#125; &#125;&#125; 实现单击，如果当前滚动到的图片在原主界面可视范围内，就动态返回原主界面当前滚动到的图片位置，如果不在当前可视范围内，就动画消失函数: 123456789101112131415161718192021// tap事件- (void)singleTap &#123; CGRect originalRect = [self targetRectForIndex:_currentIndex]; self.userInteractionEnabled = NO; self.zoomScale = 1; [UIView animateWithDuration:0.5 animations:^&#123; if (CGRectEqualToRect(originalRect, CGRectZero)) &#123; self.alpha = 0; &#125;else&#123; self.myImageView.frame = originalRect; &#125; self.superview.superview.backgroundColor = [UIColor clearColor]; self.superview.backgroundColor = [UIColor clearColor]; self.backgroundColor = [UIColor clearColor]; &#125; completion:^(BOOL finished) &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(scrollViewDidClick)]) &#123; [self.delegate performSelector:@selector(scrollViewDidClick)]; &#125; &#125;];&#125; C.FJBaseScrollView a.FJBaseScrollView是FJPhotoScrollView的基类，主要实现单击返回原主界面，双击将图片放大的效果,通过touchesBegan函数来识别单击和双击:123456789101112131415161718// touch begin 标识双击和单击- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123; UITouch *touch = [touches anyObject]; NSTimeInterval delaytime = 0.3; _point = [[touches anyObject] locationInView:self]; switch (touch.tapCount) &#123; case 1: break; case 2: &#123; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(singleTap) object:nil]; [self performSelector:@selector(doubleTap) withObject:nil afterDelay:delaytime]; break; default: break; &#125; &#125;&#125; 123456789101112// touch end- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event &#123; UITouch *touch = [touches anyObject]; switch (touch.tapCount) &#123; case 1: [self performSelector:@selector(singleTap) withObject:nil afterDelay:.2]; break; default: break; &#125;&#125; 双击调用缩放方法:12345678910// 双击-(void)doubleTap &#123; if(_isScaled == YES)&#123; [self zoomToPointInRootView:_point atScale:1]; _isScaled = NO; &#125;else&#123; [self zoomToPointInRootView:_point atScale:2]; _isScaled = YES; &#125;&#125; 设置UIScrollView缩放效果:123456789// 放大 或 缩小- (void)zoomToPointInRootView:(CGPoint)center atScale:(float)scale &#123; CGRect zoomRect; zoomRect.size.height = self.frame.size.height / scale; zoomRect.size.width = self.frame.size.width / scale; zoomRect.origin.x = center.x - (zoomRect.size.width / 2.0); zoomRect.origin.y = center.y - (zoomRect.size.height / 2.0); [self zoomToRect:zoomRect animated:YES];&#125; 单击调用代理动态返回原来界面: 123456// 单击-(void)singleTap &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(scrollViewDidClick)]) &#123; [self.delegate performSelector:@selector(scrollViewDidClick)]; &#125;&#125; 四.最后送给大家一张很喜欢的图: 这是gitHub链接地址和简书链接，大家有兴趣可以看一下，如果觉得不错，麻烦给个喜欢或star,如果有问题请及时反馈，谢谢！","tags":[{"name":"IOS","slug":"IOS","permalink":"//fjf.com/tags/IOS/"},{"name":"ImageBrowser","slug":"ImageBrowser","permalink":"//fjf.com/tags/ImageBrowser/"},{"name":"仿微信图片浏览","slug":"仿微信图片浏览","permalink":"//fjf.com/tags/仿微信图片浏览/"},{"name":"仿微博图片浏览","slug":"仿微博图片浏览","permalink":"//fjf.com/tags/仿微博图片浏览/"}]},{"title":"2016 总结","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/我的2016-年终总结/","text":"不知不觉间，2016已经走到年尾了。再过几天就是农历的除夕，粗略回想一下，真心觉得2016过得贼快，仿佛什么都没做，它就溜走了；但细细一想，其实，这一年里也发生了很多事情。而且，对于我来说很多都是大事。年底，稍微闲点，因此，总结下过往，寄语于新年。 一. 工作工作是这一整年的重心，来青柠互动也一年多了，作为初创公司的元老之一，这一年陪着公司一起成长，经历挺多，也学到挺多。 1. 工作能力 这一年来，基本都是跟着项目走，从1758广场舞到D.Talk再到D.OA,到最后一直担任D.Talk的项目负责人，负责D.Talk的迭代更新；几个项目锻炼下来，编程的思路、对于OC这么语言的理解、对于项目的掌控，以及bug的处理能力，总的来说，是有一定长足的进步。 挺感谢青柠给予的这个平台，让我可以比较完整的锻炼了，虽然其中包含了大量的加班，但能看到自己比较明显的进步，在这个快节奏的城市里，至少能有一点心安。 同时，比较空闲的时候，也自己开源了一些项目，写了一些技术博客，对于技术做了一些总结，也因为这样，认识了很多传说中的大牛，他们有的比自己还小，但是编程的功底明显比自己高很多，羡慕之余，也激发了自己的斗志。感觉这样挺踏实的。2. 工作认知 2016，移动端的风，基本已经消散，飞起来的猪，很多头先着地了。寒冬已至，作为创业公司的青柠和IOS开发的我也一样受到了影响。 去年，创业初期的25名员工，到今年年底只剩12名老员工了，当然还有40几个新员工的加入。人来人走，在IT这一行业，是一种常态，也算见怪不怪了。 离职的员工里，有些是自己想走，有些是被公司开除的，看着熟悉的面孔的离别，我逐渐意识到，生存成为了公司也是我们这些开发者的目标。激烈竞争的市场为了生存或是以后的生活，公司不断优化着自己的最合理配置，程序员之间的优胜劣汰也逐步显现出来，尤其像现在IOS端人满为患。所以学习成为了我们第一要务。 学习不只是编程技能的提高，还包括着对于项目功能的理解和把控；对于app用户体验的敏锐直觉；对于市场动态的了解等，这方面我真的要感谢强哥，这一年里，他教会了我很多除了编程以外的东西，尤其是作为项目负责人的所必须的细心和用心。 3. 工作心得 这是挺幸运的一年，年会的时候，拿了最佳优秀员工，同时自己表演的节目也得了三等奖，(PS:去年是一等奖，今年选材没选好，拖累了鹏程和余红)，最后还中了128G的IPhone7。确实是挺幸运的，人生第一次中大奖，不过，光红包也发了2000多。但确实很感谢，大家的认可。 不觉间也毕业了2年多了，从福州到深圳，从鑫诺到爱高到青柠，对于工作，确实有太多不可变因素了，离开鑫诺是因为想来深圳，离开爱高，是因为风停了，公司倒了，衷心祝愿青柠会越来越好。 二. 生活这一年生活中最重要的就是完成了人生的两件大事。 1. 女朋友 作为一个单身20几年的青年，说实话，我一直都觉得24岁左右，我就应该会有女朋友了，后来力达，先有女朋友了，这更加增强了我的预感。 现在的女朋友是我高中好友的大学同学，是一起爬山的时候认识的。可能是因为兴趣爱好比较一致，后来就走到一起了。她和我兴趣爱好很像，都喜欢动漫、运动、看书，但是做事和生活方面则比较互补，我喜欢早起，她喜欢睡懒觉；我相对勤快，她相对较懒；我情商相对高点，而她智商相对高点；我做事喜欢规划，她做事比较随性。 不过我觉得这样也挺好的，关键是聊得来。 2. 房子 2016年另外最大的一件事，就是在厦门岛外翔安区买了一套120平左右的房子。 2015年末，看着深圳飞涨的房价，我就有预感，厦门也一定要涨了，但是2015年底，刚好要准备我妹妹的婚事，也没来得及跟爸妈商量。2016年初，厦门的房价上涨的趋势已经很明显了，所以岛内先点燃了，这是岛外也抬头了，我开始和爸妈合计，一开始找了一套二手房，定金付了，但是房东迟迟不交房，拖了一个多月。我开始觉得房东是看到房价上涨趋势不打算卖了，后来直接退了定金，买了首开的三期的房子。 我爸去问的时候，三期只剩下了2套房子，而且都是120平左右的高层，80到100的已经全部售罄，看着昨天从晚上2点排队到早上的长队，我开始觉得，厦门这一波房价的涨势估计要持续很久了。 有时候觉得人生真的挺悲剧的，加在深圳和厦门之间，房价分别全国第一和全国第四，看着最后剩下的2套房子，我开始纠结了，凑够了首付，接下来每个月的月供也足以压得我喘不过气来，这对于刚毕业不到两年的我来说，确实负担太大了；可是，如果这个时候，不下手，估计以后就再也没机会了。犹豫了一晚上，后来下定决心，买了。毕竟，有压力，才有动力。 从此以后我过上了房奴的生活，而且是扛着大山的房奴。开始j节制自己的花销。可现实往往不如自己所想。如果是以前自己一个人，那倒还好，可是谈恋爱，怎么可能有不花钱的呢？这一年来，其中的艰辛，不足为外人道。 如果有人问我:2016年，最深的体会是什么？ 我想我就回答两点: 1. 钱是好东西，真的是好东西。 2. 要努力提高自己赚钱的本领，然后一定要进行合理的理财规划。 三.规划1. 钻研技术 a. 对以往做过的项目，用到的知识进行总结，将一些模糊的点，理清楚。 b. 将收藏的博客和开源的项目进行相关阅读，并整理笔记，同时将自己项目中用到的一些好用的工具封装，开源，并维护好博客和开源的项目。 c. 将以前看过的算法相关的书籍的知识内容进行整理，然后将《剑指offer》、《编程之美》等相关书籍继续读完并整理笔记。 d. 将学到一半的安全知识继续学下去，然后跟志鹏学长一起研究和学习。 2. 照顾家人 a. 明年年初如果不出意外的话，我和女朋友就结婚了，虽然比预想的早了点，但确实有太多出乎意料的情况了，结婚了，在我们闽南就是成家了，就要学会担当了，要学着怎么去做好一个成年人了，我会尽力去做好的。 b. 明年也25了，对于未来，我也开始有点担忧了，之前一直觉得多学点，好好专研技术，就可以了。很多东西也没有很好去考虑，比如之后是回去厦门发展还是留着深圳；如果要回去，什么时候回去；回去之后的各种问题，比如工作薪水会不会差距很大，生活成本各个方面，对于这些我想趁着这个过年，应该静下心来好好想一想，听听家里和朋友的看法。 最后清风拂过，老了嫩叶，绿了季节！2016，真的成长了很多。难怪，最近我越来越喜欢喝茶了，原来真的初老了。 但愿，未来会更好，而我，会更加努力！","tags":[{"name":"总结","slug":"总结","permalink":"//fjf.com/tags/总结/"},{"name":"情感","slug":"情感","permalink":"//fjf.com/tags/情感/"}]},{"title":"Block里面的weak-strong理解","date":"2016-12-26T13:30:00.000Z","path":"2016/12/26/Block里面的weak-strong理解/","text":"快年底了，想对一些之前有点模糊的概念进行总结，所以写了总结笔记。主要参考了这几篇文章:Block技术中的weak-strong什么时候在 block 中不需要使用 weakSelf为什么 weakSelf 需要配合 strong self 使用block 什么时候需要构造循环引用 一.循环引用例子12345678910111213141516171819202122232425#import \"ViewController.h\"@interface ViewController()&#123; id _observer;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"kThemeChangeNotification\" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@\"%@\", self); &#125;]; &#125;- (void)dealloc &#123; if (_observer) &#123; [[NSNotificationCenter defaultCenter] removeObserver:_observer]; &#125;&#125; 在这段代码中，我们向通知中心注册了一个观察者，然后在dealloc时，解除该注册，看起来很正常，但这里存在循环引用。 a.消息通知block引用了self,这里self对象被block保留一次b._observer又retain该block的一份拷贝，通知中心又持有_observer.c.只要_observer对象还没有被解除注册，block就会被通知中心一直持有，从而self就不会被释放，dealloc也不会被调用d.但我们有希望在dealloc中通过removeObserver来解除注册以消除通知中心对_observer/block的保留次数。e.同时_observer是self所在类中定义赋值，被self retainf.总结:因为self要想调用dealloc就必须等通知中心移除注册，释放掉_observer,但是要想通知中心移除注册、释放掉_observer就必须调用dealloc.这样相互等待就变成了死循环。这里即便self不持有_observer也会产生循环引用问题,_observer只是为了告诉通知中心移除哪个注册。 二、解决方法:1.通过weakSelf和strongSelf 12345678910111213141516171819202122@interface ViewController()&#123; id _observer;&#125;@end@implementation ViewController#pragma mark --- life circle- (void)viewDidLoad &#123; [super viewDidLoad]; __weak __typeof (self)weakSelf = self; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"kThemeChangeNotification\" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; if (strongSelf) &#123; NSLog(@\"%@\", strongSelf); &#125; &#125;];&#125; 123456- (void)dealloc &#123; if (_observer) &#123; [[NSNotificationCenter defaultCenter] removeObserver:_observer]; &#125;&#125; 在这段代码中，通过在block之前定义对self的弱引用，来解决了循环引用问题。 a.在block之前定义对self的一个弱引用weakSelf,因为是弱引用，所以self被释放时weakSelf会变为nil;b.在block中引用该弱引用，考虑到多线程情况，通过强引用strongSelf来引用该弱引用，这时如果self不为nil就会retain self,以防止在block内部使用过程中self被释放。c.在block块中使用该强引用strongSelf，注意对strongSelf进行nil检测，因为多线程在弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了d.强引用strongSelf在block作用域结束之后，自动释放。 三、block不需要使用weakSelf情况当block本身不被self持有，而被别的对象持有，同时不产生循环引用的时候，就不需要weakSelf.最常见的代码就是UIView的动画代码。我们在使用UIView的animateWithDuration:animations方法做动画的时候，并不需要使用weakSelf,因为引用的持有关系是: a.UIView的某个负责动画的对象持有了blockb.block持有了self 因为self并没有持有block,所以就不存储循环引用，因此就不需要使用weakSelf; 123[UIView animateWithDuration:0.2 animations:^&#123; self.alpha = 1;&#125;]; 当动画结束时，UIView会结束持有这个block，如果没有别的对象持有block的话，block就会释放掉，从而block就会释放对于self的持有，整个内存引用关系被解除。 四.weakSelf 为什么需要strongSelf配合使用在 block 中先写一个 strong self，其实是为了避免在 block 的执行过程中，突然出现 self 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退。 我们以 AFNetworking 中 AFNetworkReachabilityManager.m 的一段代码举例： 1234567891011__weak __typeof(self)weakSelf = self; AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; if (strongSelf) &#123; strongSelf.networkReachabilityStatus = status; if (strongSelf.networkReachabilityStatusBlock) &#123; strongSelf.networkReachabilityStatusBlock(status); &#125; &#125;&#125;; 如果没有 strongSelf 的那行代码，那么后面的每一行代码执行时，self 都可能被释放掉了，这样很可能造成逻辑异常。特别是当我们正在执行 strongSelf.networkReachabilityStatusBlock(status); 这个 block 闭包时，如果这个 block 执行到一半时 self 释放，那么多半情况下会 Crash。 五.block需要构造循环引用需要不使用 weak self 的场景是：你需要构造一个循环引用，以便保证引用双方都存在。比如你有一个后台的任务，希望任务执行完后，通知另外一个实例。在我们开源的 YTKNetwork 网络库的源码中，就有这样的场景。 在 YTKNetwork 库中，我们的每一个网络请求 API 会持有回调的 block，回调的 block 会持有 self，而如果 self 也持有网络请求 API 的话，我们就构造了一个循环引用。虽然我们构造出了循环引用，但是因为在网络请求结束时，网络请求 API 会主动释放对 block 的持有，因此，整个循环链条被解开，循环引用就被打破了，所以不会有内存泄漏问题。代码其实很简单，如下所示： 123456// YTKBaseRequest.m- (void)clearCompletionBlock &#123; // nil out to break the retain cycle. self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 总结来说，解决循环引用问题主要有两个办法： 第一个办法是「事前避免」，我们在会产生循环引用的地方使用 weak 弱引用，以避免产生循环引用。第二个办法是「事后补救」，我们明确知道会存在循环引用，但是我们在合理的位置主动断开环中的一个引用，使得对象得以回收。 五.最后:送上一张喜欢的图片: 这是简书链接如果觉得不错，麻烦给个喜欢或star,如果有问题请及时反馈，谢谢！","tags":[{"name":"Block","slug":"Block","permalink":"//fjf.com/tags/Block/"},{"name":"weakSelf","slug":"weakSelf","permalink":"//fjf.com/tags/weakSelf/"},{"name":"strongSelf","slug":"strongSelf","permalink":"//fjf.com/tags/strongSelf/"}]},{"title":"NSTimer 超时 block回调","date":"2016-12-06T12:17:00.000Z","path":"2016/12/06/NSTimer 超时 block回调/","text":"最近做直播，由于经常用到定时器进行各种比如说心跳报文发送、进入后台2分钟自动关闭直播等操作，所以经常用到定时器的超时限制(即输入定时间隔和超时次数，定时器判断重复次数超过定时次数,清空定时次数，回调block，进入下一次循环)，所以参考了这篇文章: ios 给NSTimer添加Block回调版本创建方法 一、NSTimer+Extention.h12345678910111213141516171819202122232425262728293031323334353637// DeJiaIM// Created by fjf on 2016/12/6.// Copyright © 2016年 tsningning. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;typedef void(^NSTimerBlock)(void);@interface NSTimer (Extention)/** 设置定时器 @param interval 定时间隔 @param repeats 是否重复 @param callback 回调 @return 返回定时器 */+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats timerCallback:(NSTimerBlock)callback;/** 设置定时器 @param interval 定时间隔 @param repeats 是否重复 @param limitCount 超时次数 @param timerCallback 回调 @return 返回定时器 */+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats limitCount:(NSInteger)limitCount timerCallback:(NSTimerBlock)timerCallback;@end 二、NSTimer+Extention.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// NSTimer+Extention.m// DeJiaIM//// Created by fjf on 2016/12/6.// Copyright © 2016年 tsningning. All rights reserved.//#import \"NSTimer+Extention.h\"@implementation NSTimer (Extention)+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats timerCallback:(NSTimerBlock)timerCallback &#123; return [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(onTimerUpdateBlock:) userInfo:[timerCallback copy] repeats:repeats];&#125;+ (void)onTimerUpdateBlock:(NSTimer *)timer &#123; NSTimerBlock block = timer.userInfo; if (block) &#123; block(); &#125;&#125;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats limitCount:(NSInteger)limitCount timerCallback:(NSTimerBlock)timerCallback &#123; NSDictionary *userInfo = @&#123;@\"timerCallback\" : [timerCallback copy], @\"limitCount\" : @(limitCount)&#125;; return [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(beyoudLimitTime:) userInfo:userInfo repeats:repeats];&#125;+ (void)beyoudLimitTime:(NSTimer *)timer &#123; static NSUInteger currentCount = 0; NSDictionary *userInfo = timer.userInfo; NSTimerBlock timerCallBack = userInfo[@\"timerCallback\"]; NSNumber *count = userInfo[@\"limitCount\"]; currentCount ++; if (currentCount &gt; count.integerValue) &#123; if (timerCallBack) &#123; currentCount = 0; timerCallBack(); &#125; &#125;&#125; 三.最后:送上一张喜欢的图片: 这是简书链接如果觉得不错，麻烦给个喜欢或star,如果有问题请及时反馈，谢谢！","tags":[{"name":"Block","slug":"Block","permalink":"//fjf.com/tags/Block/"},{"name":"NSTimer","slug":"NSTimer","permalink":"//fjf.com/tags/NSTimer/"},{"name":"超时 回调","slug":"超时-回调","permalink":"//fjf.com/tags/超时-回调/"}]},{"title":"OC工具类:防崩溃策略(runtime机制)","date":"2016-11-28T09:48:00.000Z","path":"2016/11/28/OC工具类防崩溃策略(runtime机制)/","text":"由于上一篇文章中，很多人都说通过类别拓展，添加新方法，然后对新方法进行判断，来达到防止崩溃的目的，这样做法不利于项目的维护和后期的扩展，毕竟长期以来大家习惯了用系统自带的方法。所以最好的方法就是在系统方法里面判断，因此研究了下,通过runtime机制替换了系统的方法，来对参数添加判断，以此来防止崩溃现象。主要启发自这篇文章: 从NSArray看类簇，这篇文章比较详细介绍了类簇的设计模式。 一.原理1.由于NSString、NSArray、NSMutableString、NSMutableArray、NSMutableDictionary这几个类型都是Class Clusters（类簇）设计模式设计出来的，它们偷偷隐藏了很多具体的实现类， 只暴露出简单的接口来供外层调用，实现了很好的封装。 首先我们利用 NSArray 的几个方法来创建实例对象: 123456789101112(lldb) po [NSArray array]&lt;__NSArray0 0x600000017670&gt;()(lldb) po [NSArray arrayWithObject:@\"Hello,Zie\"];&lt;__NSSingleObjectArrayI 0x600000017680&gt;(Hello,Zie)po [NSArray arrayWithObjects:@1,@2, nil];&lt;__NSArrayI 0x100500050&gt;(1,2) 通过打印可以看到由 NSArray ，创建的对象并不是 NSArray 本身，有可能是NSArray0 ,NSSingleObjectArrayI 、NSArrayI ， 这里 NSArray 就是那个抽象类，而被创建出来那些奇奇怪的类就是作为具体的实现类，同时是内部私有的。 所以通过运行时的class_addMethod和class_replaceMethod来添加方法或是通过method_exchangeImplementations来替换系统中对应的原生方法必须依据它具体的实现类，也就是说必须依据NSArray0 、NSSingleObjectArrayI 、NSArrayI这三者，而不能依据NSArray。 二.具体实现:以NSString和NSMutableArray为例1.NSString NSString实例类型.png 经发现NSString实际的实现类有NSCFConstantString、NSTaggedPointerString、NSCFString&gt;这三者，由于NSMutableString主要实现类是NSCFString，所以将NSCFString相应的替代方法放到NSMutableString相关文件里面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#import &lt;objc/runtime.h&gt;#import \"NSString+Safe.h\"@implementation NSString (Safe)#pragma mark --- init method+ (void)load &#123; //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSString *tmpSubFromStr = @\"substringFromIndex:\"; NSString *tmpSafeSubFromStr = @\"safe_substringFromIndex:\"; NSString *tmpSafePointSubFromStr = @\"safePoint_substringFromIndex:\"; [self exchangeImplementationWithClassStr:@\"__NSCFConstantString\" originalMethodStr:tmpSubFromStr newMethodStr:tmpSafeSubFromStr]; [self exchangeImplementationWithClassStr:@\"NSTaggedPointerString\" originalMethodStr:tmpSubFromStr newMethodStr:tmpSafePointSubFromStr]; NSString *tmpSubToStr = @\"substringToIndex:\"; NSString *tmpSafeSubToStr = @\"safe_substringToIndex:\"; NSString *tmpSafePointSubToStr = @\"safePoint_substringToIndex:\"; [self exchangeImplementationWithClassStr:@\"__NSCFConstantString\" originalMethodStr:tmpSubToStr newMethodStr:tmpSafeSubToStr]; [self exchangeImplementationWithClassStr:@\"NSTaggedPointerString\" originalMethodStr:tmpSubToStr newMethodStr:tmpSafePointSubToStr]; NSString *tmpSubRangeStr = @\"substringWithRange:\"; NSString *tmpSafeSubRangeStr = @\"safe_substringWithRange:\"; NSString *tmpSafePointSubRangeStr = @\"safePoint_substringWithRange:\"; [self exchangeImplementationWithClassStr:@\"__NSCFConstantString\" originalMethodStr:tmpSubRangeStr newMethodStr:tmpSafeSubRangeStr]; [self exchangeImplementationWithClassStr:@\"NSTaggedPointerString\" originalMethodStr:tmpSubRangeStr newMethodStr:tmpSafePointSubRangeStr]; NSString *tmpRangeOfStr = @\"rangeOfString:options:range:locale:\"; NSString *tmpSafeRangeOfStr = @\"safe_rangeOfString:options:range:locale:\"; NSString *tmpSafePointRangeOfStr = @\"safePoint_rangeOfString:options:range:locale:\"; [self exchangeImplementationWithClassStr:@\"__NSCFConstantString\" originalMethodStr:tmpRangeOfStr newMethodStr:tmpSafeRangeOfStr]; [self exchangeImplementationWithClassStr:@\"NSTaggedPointerString\" originalMethodStr:tmpRangeOfStr newMethodStr:tmpSafePointRangeOfStr]; &#125;);&#125; 这里因为将放到NSMutableString类别里面去替换，所以只做实例类__NSCFConstantString、NSTaggedPointerString的替换。因为最终调用替换函数:method_exchangeImplementations(originalMethod, swizzledMethod);，所以 123NSString *tmpSubFromStr = @\"substringFromIndex:\"; NSString *tmpSafeSubFromStr = @\"safe_substringFromIndex:\"; NSString *tmpSafePointSubFromStr = @\"safePoint_substringFromIndex:\"; 每一个实例类别都应该有自己相对应的替换方法,这里tmpSubFromStr是系统的方法，tmpSafeSubFromStr是__NSCFConstantString实例类对应的替换方法，tmpSafePointSubFromStr是NSTaggedPointerString对应的替换方法。这里虽然是NSString，可以通过 SEL originalSelector = NSSelectorFromString(originalMethodStr); SEL swizzledSelector = NSSelectorFromString(newMethodStr); 转换成相应的SEL方法。如果每个实力类没有自己对应的方法，比如说像这样: NSString *tmpSubFromStr = @&quot;substringFromIndex:&quot;; NSString *tmpSafeSubFromStr = @&quot;safe_substringFromIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFConstantString&quot; originalMethodStr:tmpSubFromStr newMethodStr:tmpSafeSubFromStr]; [self exchangeImplementationWithClassStr:@&quot;NSTaggedPointerString&quot; originalMethodStr:tmpSubFromStr newMethodStr:tmpSafeSubFromStr]; 那最终只会对NSTaggedPointerString原来的substringFromIndex:函数进行替换，__NSCFConstantString实例类型的就不起作用。 // 获取 method + (Method)methodOfClassStr:(NSString *)classStr selector:(SEL)selector { return class_getInstanceMethod(NSClassFromString(classStr),selector); } // 判断添加 新方法 或 新方法 替换 原来 方法 + (void)exchangeImplementationWithClassStr:(NSString *)classStr originalMethodStr:(NSString *)originalMethodStr newMethodStr:(NSString *)newMethodStr { SEL originalSelector = NSSelectorFromString(originalMethodStr); SEL swizzledSelector = NSSelectorFromString(newMethodStr); Method originalMethod = [NSString methodOfClassStr:classStr selector:NSSelectorFromString(originalMethodStr)]; Method swizzledMethod = [NSString methodOfClassStr:classStr selector:NSSelectorFromString(newMethodStr)]; // 判断 是否 可以添加 新方法 BOOL didAddMethod = class_addMethod(NSClassFromString(classStr), originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(NSClassFromString(classStr), swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { // 替换 原有 方法 method_exchangeImplementations(originalMethod, swizzledMethod); } } 这段代码主要通过运行时，先判断是否可以往该实际类里面添加新方法，如果可以则添加新方法，如果不行，则替换原有的方法。但我们要替换的函数一般系统包含，所以只会走替换函数method_exchangeImplementations，但为了系统的健壮性，还是有必要先进行判断。 #pragma mark --- implement method /**************************************** substringFromIndex: ***********************************/ /** 从from位置截取字符串 对应 __NSCFConstantString @param from 截取起始位置 @return 截取的子字符串 */ - (NSString *)safe_substringFromIndex:(NSUInteger)from { if (from &gt; self.length ) { return nil; } return [self safe_substringFromIndex:from]; } /** 从from位置截取字符串 对应 NSTaggedPointerString @param from 截取起始位置 @return 截取的子字符串 */ - (NSString *)safePoint_substringFromIndex:(NSUInteger)from { if (from &gt; self.length ) { return nil; } return [self safePoint_substringFromIndex:from]; } /**************************************** substringFromIndex: ***********************************/ /** 从开始截取到to位置的字符串 对应 __NSCFConstantString @param to 截取终点位置 @return 返回截取的字符串 */ - (NSString *)safe_substringToIndex:(NSUInteger)to { if (to &gt; self.length ) { return nil; } return [self safe_substringToIndex:to]; } /** 从开始截取到to位置的字符串 对应 NSTaggedPointerString @param to 截取终点位置 @return 返回截取的字符串 */ - (NSString *)safePoint_substringToIndex:(NSUInteger)to { if (to &gt; self.length ) { return nil; } return [self safePoint_substringToIndex:to]; } /*********************************** rangeOfString:options:range:locale: ***************************/ /** 搜索指定 字符串 对应 __NSCFConstantString @param searchString 指定 字符串 @param mask 比较模式 @param rangeOfReceiverToSearch 搜索 范围 @param locale 本地化 @return 返回搜索到的字符串 范围 */ - (NSRange)safe_rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask range:(NSRange)rangeOfReceiverToSearch locale:(nullable NSLocale *)locale { if (!searchString) { searchString = self; } if (rangeOfReceiverToSearch.location &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if (rangeOfReceiverToSearch.length &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if ((rangeOfReceiverToSearch.location + rangeOfReceiverToSearch.length) &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } return [self safe_rangeOfString:searchString options:mask range:rangeOfReceiverToSearch locale:locale]; } /** 搜索指定 字符串 对应 NSTaggedPointerString @param searchString 指定 字符串 @param mask 比较模式 @param rangeOfReceiverToSearch 搜索 范围 @param locale 本地化 @return 返回搜索到的字符串 范围 */ - (NSRange)safePoint_rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask range:(NSRange)rangeOfReceiverToSearch locale:(nullable NSLocale *)locale { if (!searchString) { searchString = self; } if (rangeOfReceiverToSearch.location &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if (rangeOfReceiverToSearch.length &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if ((rangeOfReceiverToSearch.location + rangeOfReceiverToSearch.length) &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } return [self safePoint_rangeOfString:searchString options:mask range:rangeOfReceiverToSearch locale:locale]; } /*********************************** substringWithRange: ***************************/ /** 截取指定范围的字符串 对应 __NSCFConstantString @param range 指定的范围 @return 返回截取的字符串 */ - (NSString *)safe_substringWithRange:(NSRange)range { if (range.location &gt; self.length) { return nil; } if (range.length &gt; self.length) { return nil; } if ((range.location + range.length) &gt; self.length) { return nil; } return [self safe_substringWithRange:range]; } /** 截取指定范围的字符串 对应 NSTaggedPointerString @param range 指定的范围 @return 返回截取的字符串 */ - (NSString *)safePoint_substringWithRange:(NSRange)range { if (range.location &gt; self.length) { return nil; } if (range.length &gt; self.length) { return nil; } if ((range.location + range.length) &gt; self.length) { return nil; } return [self safePoint_substringWithRange:range]; } @end 这里是具体的替换方法，对传入的参数进行判断，如果参数合理，就执行原来系统的方法，如果参数不合理，就直接返回适当内容(一般返回nil或直接return)；这里主要说一点： // __NSCFConstantString 类型 NSString *tmpConstantString = @&quot;432423432432432432&quot;; [tmpConstantString rangeOfString:nil]; 比如说系统原有的rangeOfString:函数，当你传入为nil的时候，就会导致崩溃，所以你很容易，就会去替换掉系统的该函数，但这是没有效果的， NSString的rangeOfString.png 从这里我们可以看出来，真正导致系统崩溃的是rangeOfString:options:range:locale:执行了系统的该函数，所以应该去替换的是系统的rangeOfString:options:range:locale:这个函数。 同样的NSMutableArray： // __NSArrayM 类型 NSMutableArray *tmpMutableArrayM = [NSMutableArray arrayWithCapacity:0]; [tmpMutableArrayM removeObjectAtIndex:1000]; NSMutableArray的removeObjectAtIndex函数传入一个超过数组本身长度的索引，就会导致崩溃，所以你去替换系统的removeObjectAtIndex方法这样也是没有效果的 NSMutableArray的removeObjectAtIndex.png 因为真正导致该崩溃的因为是因为系统执行了removeObjectsInRange:函数，函数里面的参数range超出了数组的范围，需要对该参数进行判断，才能有效的防止崩溃，所以替换系统的方法，必须先清楚引起系统崩溃的具体原因，才能对症下药。 2.NSMutableArray NSMutableArray主要原理跟NSString是一样的，但这里有一点需要注意的: 由于NSArray和NSMutableArray里面都有objectAtIndex这个原生函数，但是NSArray和NSMutableArray的实际类不一样，所以NSArray和NSMutableArray里面的替换方法必须不一样，否则因为替换 method_exchangeImplementations(originalMethod, swizzledMethod);只是简单的进行将新方法替换掉原有的方法，但是它并没有类别的区分，所以如果NSArray和NSMutableArray里面的替换方法一样，那就只会执行NSMutableArray里面的替换方法，NSArray里面的不起作用(NSArray里面的load方法先执行)。 三.总结1.NSArray 主要替换objectAtIndex:方法 + (void)load { //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ //替换 objectAtIndex NSString *tmpStr = @&quot;objectAtIndex:&quot;; NSString *tmpFirstStr = @&quot;safe_ZeroObjectAtIndex:&quot;; NSString *tmpThreeStr = @&quot;safe_objectAtIndex:&quot;; NSString *tmpSecondStr = @&quot;safe_singleObjectAtIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSArray0&quot; originalMethodStr:tmpStr newMethodStr:tmpFirstStr]; [self exchangeImplementationWithClassStr:@&quot;__NSSingleObjectArrayI&quot; originalMethodStr:tmpStr newMethodStr:tmpSecondStr]; [self exchangeImplementationWithClassStr:@&quot;__NSArrayI&quot; originalMethodStr:tmpStr newMethodStr:tmpThreeStr]; }); } 实现方法: #pragma mark --- implement method /** 取出NSArray 第index个 值 对应 __NSArrayI @param index 索引 index @return 返回值 */ - (id)safe_objectAtIndex:(NSUInteger)index { if (index &gt;= self.count){ return nil; } return [self safe_objectAtIndex:index]; } /** 取出NSArray 第index个 值 对应 __NSSingleObjectArrayI @param index 索引 index @return 返回值 */ - (id)safe_singleObjectAtIndex:(NSUInteger)index { if (index &gt;= self.count){ return nil; } return [self safe_singleObjectAtIndex:index]; } /** 取出NSArray 第index个 值 对应 __NSArray0 @param index 索引 index @return 返回值 */ - (id)safe_ZeroObjectAtIndex:(NSUInteger)index { if (index &gt;= self.count){ return nil; } return [self safe_ZeroObjectAtIndex:index]; } 2.NSMutableArray 主要替换方法:objectAtIndex:、removeObjectsInRange:、insertObject:atIndex:、removeObject:inRange:这几个方法 + (void)load { //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ //替换 objectAtIndex: NSString *tmpGetStr = @&quot;objectAtIndex:&quot;; NSString *tmpSafeGetStr = @&quot;safeMutable_objectAtIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSArrayM&quot; originalMethodStr:tmpGetStr newMethodStr:tmpSafeGetStr]; //替换 removeObjectsInRange: NSString *tmpRemoveStr = @&quot;removeObjectsInRange:&quot;; NSString *tmpSafeRemoveStr = @&quot;safeMutable_removeObjectsInRange:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSArrayM&quot; originalMethodStr:tmpRemoveStr newMethodStr:tmpSafeRemoveStr]; //替换 insertObject:atIndex: NSString *tmpInsertStr = @&quot;insertObject:atIndex:&quot;; NSString *tmpSafeInsertStr = @&quot;safeMutable_insertObject:atIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSArrayM&quot; originalMethodStr:tmpInsertStr newMethodStr:tmpSafeInsertStr]; //替换 removeObject:inRange: NSString *tmpRemoveRangeStr = @&quot;removeObject:inRange:&quot;; NSString *tmpSafeRemoveRangeStr = @&quot;safeMutable_removeObject:inRange:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSArrayM&quot; originalMethodStr:tmpRemoveRangeStr newMethodStr:tmpSafeRemoveRangeStr]; }); } 实现方法: #pragma mark --- implement method /** 取出NSArray 第index个 值 @param index 索引 index @return 返回值 */ - (id)safeMutable_objectAtIndex:(NSUInteger)index { if (index &gt;= self.count){ return nil; } return [self safeMutable_objectAtIndex:index]; } /** NSMutableArray 移除 索引 index 对应的 值 @param range 移除 范围 */ - (void)safeMutable_removeObjectsInRange:(NSRange)range { if (range.location &gt; self.count) { return; } if (range.length &gt; self.count) { return; } if ((range.location + range.length) &gt; self.count) { return; } return [self safeMutable_removeObjectsInRange:range]; } /** 在range范围内， 移除掉anObject @param anObject 移除的anObject @param range 范围 */ - (void)safeMutable_removeObject:(id)anObject inRange:(NSRange)range { if (range.location &gt; self.count) { return; } if (range.length &gt; self.count) { return; } if ((range.location + range.length) &gt; self.count) { return; } if (!anObject){ return; } return [self safeMutable_removeObject:anObject inRange:range]; } /** NSMutableArray 插入 新值 到 索引index 指定位置 @param anObject 新值 @param index 索引 index */ - (void)safeMutable_insertObject:(id)anObject atIndex:(NSUInteger)index { if (index &gt; self.count) { return; } if (!anObject){ return; } [self safeMutable_insertObject:anObject atIndex:index]; } 3.NSString 主要替换方法:substringFromIndex:,substringToIndex:,substringWithRange:,rangeOfString:options:range:locale:这几个主要方法 + (void)load { //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 替换 substringFromIndex: NSString *tmpSubFromStr = @&quot;substringFromIndex:&quot;; NSString *tmpSafeSubFromStr = @&quot;safe_substringFromIndex:&quot;; NSString *tmpSafePointSubFromStr = @&quot;safePoint_substringFromIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFConstantString&quot; originalMethodStr:tmpSubFromStr newMethodStr:tmpSafeSubFromStr]; [self exchangeImplementationWithClassStr:@&quot;NSTaggedPointerString&quot; originalMethodStr:tmpSubFromStr newMethodStr:tmpSafePointSubFromStr]; // 替换 substringToIndex: NSString *tmpSubToStr = @&quot;substringToIndex:&quot;; NSString *tmpSafeSubToStr = @&quot;safe_substringToIndex:&quot;; NSString *tmpSafePointSubToStr = @&quot;safePoint_substringToIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFConstantString&quot; originalMethodStr:tmpSubToStr newMethodStr:tmpSafeSubToStr]; [self exchangeImplementationWithClassStr:@&quot;NSTaggedPointerString&quot; originalMethodStr:tmpSubToStr newMethodStr:tmpSafePointSubToStr]; // 替换 substringWithRange: NSString *tmpSubRangeStr = @&quot;substringWithRange:&quot;; NSString *tmpSafeSubRangeStr = @&quot;safe_substringWithRange:&quot;; NSString *tmpSafePointSubRangeStr = @&quot;safePoint_substringWithRange:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFConstantString&quot; originalMethodStr:tmpSubRangeStr newMethodStr:tmpSafeSubRangeStr]; [self exchangeImplementationWithClassStr:@&quot;NSTaggedPointerString&quot; originalMethodStr:tmpSubRangeStr newMethodStr:tmpSafePointSubRangeStr]; // 替换 rangeOfString:options:range:locale: NSString *tmpRangeOfStr = @&quot;rangeOfString:options:range:locale:&quot;; NSString *tmpSafeRangeOfStr = @&quot;safe_rangeOfString:options:range:locale:&quot;; NSString *tmpSafePointRangeOfStr = @&quot;safePoint_rangeOfString:options:range:locale:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFConstantString&quot; originalMethodStr:tmpRangeOfStr newMethodStr:tmpSafeRangeOfStr]; [self exchangeImplementationWithClassStr:@&quot;NSTaggedPointerString&quot; originalMethodStr:tmpRangeOfStr newMethodStr:tmpSafePointRangeOfStr]; }); } 实现方法: #pragma mark --- implement method /**************************************** substringFromIndex: ***********************************/ /** 从from位置截取字符串 对应 __NSCFConstantString @param from 截取起始位置 @return 截取的子字符串 */ - (NSString *)safe_substringFromIndex:(NSUInteger)from { if (from &gt; self.length ) { return nil; } return [self safe_substringFromIndex:from]; } /** 从from位置截取字符串 对应 NSTaggedPointerString @param from 截取起始位置 @return 截取的子字符串 */ - (NSString *)safePoint_substringFromIndex:(NSUInteger)from { if (from &gt; self.length ) { return nil; } return [self safePoint_substringFromIndex:from]; } /**************************************** substringFromIndex: ***********************************/ /** 从开始截取到to位置的字符串 对应 __NSCFConstantString @param to 截取终点位置 @return 返回截取的字符串 */ - (NSString *)safe_substringToIndex:(NSUInteger)to { if (to &gt; self.length ) { return nil; } return [self safe_substringToIndex:to]; } /** 从开始截取到to位置的字符串 对应 NSTaggedPointerString @param to 截取终点位置 @return 返回截取的字符串 */ - (NSString *)safePoint_substringToIndex:(NSUInteger)to { if (to &gt; self.length ) { return nil; } return [self safePoint_substringToIndex:to]; } /*********************************** rangeOfString:options:range:locale: ***************************/ /** 搜索指定 字符串 对应 __NSCFConstantString @param searchString 指定 字符串 @param mask 比较模式 @param rangeOfReceiverToSearch 搜索 范围 @param locale 本地化 @return 返回搜索到的字符串 范围 */ - (NSRange)safe_rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask range:(NSRange)rangeOfReceiverToSearch locale:(nullable NSLocale *)locale { if (!searchString) { searchString = self; } if (rangeOfReceiverToSearch.location &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if (rangeOfReceiverToSearch.length &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if ((rangeOfReceiverToSearch.location + rangeOfReceiverToSearch.length) &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } return [self safe_rangeOfString:searchString options:mask range:rangeOfReceiverToSearch locale:locale]; } /** 搜索指定 字符串 对应 NSTaggedPointerString @param searchString 指定 字符串 @param mask 比较模式 @param rangeOfReceiverToSearch 搜索 范围 @param locale 本地化 @return 返回搜索到的字符串 范围 */ - (NSRange)safePoint_rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask range:(NSRange)rangeOfReceiverToSearch locale:(nullable NSLocale *)locale { if (!searchString) { searchString = self; } if (rangeOfReceiverToSearch.location &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if (rangeOfReceiverToSearch.length &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if ((rangeOfReceiverToSearch.location + rangeOfReceiverToSearch.length) &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } return [self safePoint_rangeOfString:searchString options:mask range:rangeOfReceiverToSearch locale:locale]; } /*********************************** substringWithRange: ***************************/ /** 截取指定范围的字符串 对应 __NSCFConstantString @param range 指定的范围 @return 返回截取的字符串 */ - (NSString *)safe_substringWithRange:(NSRange)range { if (range.location &gt; self.length) { return nil; } if (range.length &gt; self.length) { return nil; } if ((range.location + range.length) &gt; self.length) { return nil; } return [self safe_substringWithRange:range]; } /** 截取指定范围的字符串 对应 NSTaggedPointerString @param range 指定的范围 @return 返回截取的字符串 */ - (NSString *)safePoint_substringWithRange:(NSRange)range { if (range.location &gt; self.length) { return nil; } if (range.length &gt; self.length) { return nil; } if ((range.location + range.length) &gt; self.length) { return nil; } return [self safePoint_substringWithRange:range]; } 4.NSMutableString 主要替换方法:substringFromIndex:,substringToIndex:,substringWithRange:,rangeOfString:options:range:locale:，appendString,这几个主要方法 + (void)load { //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 替换 substringFromIndex: NSString *tmpSubFromStr = @&quot;substringFromIndex:&quot;; NSString *tmpSafeSubFromStr = @&quot;safeMutable_substringFromIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFString&quot; originalMethodStr:tmpSubFromStr newMethodStr:tmpSafeSubFromStr]; // 替换 substringToIndex: NSString *tmpSubToStr = @&quot;substringToIndex:&quot;; NSString *tmpSafeSubToStr = @&quot;safeMutable_substringToIndex:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFString&quot; originalMethodStr:tmpSubToStr newMethodStr:tmpSafeSubToStr]; // 替换 substringWithRange: NSString *tmpSubRangeStr = @&quot;substringWithRange:&quot;; NSString *tmpSafeSubRangeStr = @&quot;safeMutable_substringWithRange:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFString&quot; originalMethodStr:tmpSubRangeStr newMethodStr:tmpSafeSubRangeStr]; // 替换 rangeOfString:options:range:locale: NSString *tmpRangeOfStr = @&quot;rangeOfString:options:range:locale:&quot;; NSString *tmpSafeRangeOfStr = @&quot;safeMutable_rangeOfString:options:range:locale:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFString&quot; originalMethodStr:tmpRangeOfStr newMethodStr:tmpSafeRangeOfStr]; // 替换 appendString NSString *tmpAppendStr = @&quot;appendString:&quot;; NSString *tmpSafeAppendStr = @&quot;safeMutable_appendString:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSCFString&quot; originalMethodStr:tmpAppendStr newMethodStr:tmpSafeAppendStr]; }); } 实现方法: #pragma mark --- implement method /**************************************** substringFromIndex: ***********************************/ /** 从from位置截取字符串 对应 __NSCFString @param from 截取起始位置 @return 截取的子字符串 */ - (NSString *)safeMutable_substringFromIndex:(NSUInteger)from { if (from &gt; self.length ) { return nil; } return [self safeMutable_substringFromIndex:from]; } /**************************************** substringFromIndex: ***********************************/ /** 从开始截取到to位置的字符串 对应 __NSCFString @param to 截取终点位置 @return 返回截取的字符串 */ - (NSString *)safeMutable_substringToIndex:(NSUInteger)to { if (to &gt; self.length ) { return nil; } return [self safeMutable_substringToIndex:to]; } /*********************************** rangeOfString:options:range:locale: ***************************/ /** 搜索指定 字符串 对应 __NSCFString @param searchString 指定 字符串 @param mask 比较模式 @param rangeOfReceiverToSearch 搜索 范围 @param locale 本地化 @return 返回搜索到的字符串 范围 */ - (NSRange)safeMutable_rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask range:(NSRange)rangeOfReceiverToSearch locale:(nullable NSLocale *)locale { if (!searchString) { searchString = self; } if (rangeOfReceiverToSearch.location &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if (rangeOfReceiverToSearch.length &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } if ((rangeOfReceiverToSearch.location + rangeOfReceiverToSearch.length) &gt; self.length) { rangeOfReceiverToSearch = NSMakeRange(0, self.length); } return [self safeMutable_rangeOfString:searchString options:mask range:rangeOfReceiverToSearch locale:locale]; } /*********************************** substringWithRange: ***************************/ /** 截取指定范围的字符串 对应 __NSCFString @param range 指定的范围 @return 返回截取的字符串 */ - (NSString *)safeMutable_substringWithRange:(NSRange)range { if (range.location &gt; self.length) { return nil; } if (range.length &gt; self.length) { return nil; } if ((range.location + range.length) &gt; self.length) { return nil; } return [self safeMutable_substringWithRange:range]; } /*********************************** safeMutable_appendString: ***************************/ /** 追加字符串 对应 __NSCFString @param aString 追加的字符串 */ - (void)safeMutable_appendString:(NSString *)aString { if (!aString) { return; } return [self safeMutable_appendString:aString]; } 5.NSMutableDictionary 主要替换removeObjectForKey:和 setObject:forKey:这两个方法 + (void)load { //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 替换 removeObjectForKey: NSString *tmpRemoveStr = @&quot;removeObjectForKey:&quot;; NSString *tmpSafeRemoveStr = @&quot;safeMutable_removeObjectForKey:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSDictionaryM&quot; originalMethodStr:tmpRemoveStr newMethodStr:tmpSafeRemoveStr]; // 替换 setObject:forKey: NSString *tmpSetStr = @&quot;setObject:forKey:&quot;; NSString *tmpSafeSetRemoveStr = @&quot;safeMutable_setObject:forKey:&quot;; [self exchangeImplementationWithClassStr:@&quot;__NSDictionaryM&quot; originalMethodStr:tmpSetStr newMethodStr:tmpSafeSetRemoveStr]; }); } 实现方法:1234567891011121314151617181920212223242526272829#pragma mark --- implement method/** 根据akey 移除 对应的 键值对 @param aKey key */- (void)safeMutable_removeObjectForKey:(id&lt;NSCopying&gt;)aKey &#123; if (!aKey) &#123; return; &#125; [self safeMutable_removeObjectForKey:aKey];&#125;/** 将键值对 添加 到 NSMutableDictionary 内 @param anObject 值 @param aKey 键 */- (void)safeMutable_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey &#123; if (!anObject) &#123; return; &#125; if (!aKey) &#123; return; &#125; return [self safeMutable_setObject:anObject forKey:aKey];&#125; 四: 感想1. 常见坑 Method swizzling 是非原子性的，在多线程环境下可能被多次修改，但同样 Method swizzling 又是全局性的，就会造成不可预知的错误。 可能出现命名冲突的问题，这样就不会调用到系统原方法，可能导致未知问题。 Method swizzling 看起来像递归，对新人来说不容易理解。 出现问题 Method swizzling 不容易进行debug，来发现问题 随着项目迭代和人员更换，使用Method swizzling 的项目不容易维护，因为开发人员有时根本不知道在Method swizzling 里面修改了东西。 2.总结runtime是把双刃剑，因为所有的代码都运行在它之上，改变它，可能会改变代码的正常运行逻辑和所有与之交互的东西，因此会产生可怕的副作用。但同时它强大的功能也可以给应用的框架或者代码的编写带来非常大的遍历。 因此，对于runtime唯一的建议就是，需谨慎使用，一旦使用，必须先了解runtime的相关原理，做好预防措施，在添加完自己的代码之后，一定要调用系统原来的方法。 五: 最后送上一张喜欢的图片: 提醒:不应该把runtime的使用看成是高大上的东西，并以使用这个为荣，实际开发中runtime能少用应该少用，正常的系统方法才是正道！ 这是gitHub链接地址:FJ_Safe和简书链接,大家有兴趣可以看一下，如果觉得不错，麻烦给个喜欢或star,若发现问题请及时反馈，谢谢！ – 2017，新的开始！","tags":[{"name":"IOS","slug":"IOS","permalink":"//fjf.com/tags/IOS/"},{"name":"Runtime","slug":"Runtime","permalink":"//fjf.com/tags/Runtime/"},{"name":"Method Swizzling","slug":"Method-Swizzling","permalink":"//fjf.com/tags/Method-Swizzling/"},{"name":"NSAaray,NSMutableArray 数组越界","slug":"NSAaray-NSMutableArray-数组越界","permalink":"//fjf.com/tags/NSAaray-NSMutableArray-数组越界/"},{"name":"NSString, NSMutableString 崩溃","slug":"NSString-NSMutableString-崩溃","permalink":"//fjf.com/tags/NSString-NSMutableString-崩溃/"}]},{"title":"FJFloatingView 可停靠任意位置悬浮窗","date":"2016-10-22T11:27:00.000Z","path":"2016/10/22/FJFloatingView 可停靠任意位置悬浮窗/","text":"由于项目需求，需要一个悬浮窗口，随手势移动，可以停靠在任意位置，所以自己整了一个，简单封装一下，希望能帮到有需要的朋友。 一.效果图FJFloatingView效果图# 二.使用方法12FJFloatingView *floatingView = [[FJFloatingView alloc] initWithFrame:CGRectMake(100, 100, FJ_FLOATING_VOICE_VIEW_SIZE, FJ_FLOATING_VOICE_VIEW_SIZE)]; [self.view addSubview:floatingView];# 三.主要代码分析:123456789滑动范围四个值:// 上边距(默认值:0)@property (nonatomic, assign) CGFloat upEdgeDistance;// 右边距(右边距:SCREEN_WIDTH)@property (nonatomic, assign) CGFloat downEdgeDistance;// 左边距(默认值:0)@property (nonatomic, assign) CGFloat leftEdgeDistance;// 下边距(默认值:SCREEN_HEIGHT)@property (nonatomic, assign) CGFloat rightEdgeDistance;这四个值主要是有利于需求的扩展，比如需求规定不能超过状态栏，只需将上边距设为20即可。手势滑动处理函数，限定floatingView在规定的范围滑动:123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma mark --- response event-(void)pan:(UIPanGestureRecognizer *)sender &#123; switch (sender.state) &#123; case UIGestureRecognizerStateBegan: &#123; _beganPoint = [sender locationInView:self.superview]; _curPoint = self.center; &#125; break; case UIGestureRecognizerStateChanged: &#123; CGPoint point = [sender locationInView:self.superview]; NSInteger x_offset = point.x - _beganPoint.x; NSInteger y_offset = point.y - _beganPoint.y; self.tmpView.center = self.center; self.tmpView.center = CGPointMake(_curPoint.x + x_offset, _curPoint.y + y_offset); // 设置 左边距 if (CGRectGetMinX(self.tmpView.frame) &lt; self.leftEdgeDistance)&#123; x_offset -= CGRectGetMinX(self.tmpView.frame); &#125; // 设置 右边距 if (CGRectGetMaxX(self.tmpView.frame) &gt; self.rightEdgeDistance) &#123; x_offset += SCREEN_WIDTH - CGRectGetMaxX(self.tmpView.frame); &#125; // 设置 上边距 if (CGRectGetMinY(self.tmpView.frame) &lt; self.upEdgeDistance) &#123; y_offset -= CGRectGetMinY(self.tmpView.frame); &#125; // 设置 下边距 if (CGRectGetMaxY(self.tmpView.frame) &gt; self.downEdgeDistance) &#123; y_offset += self.downEdgeDistance - CGRectGetMaxY(self.tmpView.frame); &#125; self.center = CGPointMake(_curPoint.x + x_offset, _curPoint.y + y_offset); &#125; break; case UIGestureRecognizerStateEnded: break; default: break; &#125;&#125;# 四.最后:送上一张喜欢的图片: 这是gitHub链接地址和简书链接，大家有兴趣可以看一下，如果觉得不错，麻烦给个喜欢或star,如果有问题请及时反馈，谢谢！","tags":[{"name":"IOS","slug":"IOS","permalink":"//fjf.com/tags/IOS/"},{"name":"UI","slug":"UI","permalink":"//fjf.com/tags/UI/"},{"name":"悬浮窗","slug":"悬浮窗","permalink":"//fjf.com/tags/悬浮窗/"},{"name":"Assistive Touch","slug":"Assistive-Touch","permalink":"//fjf.com/tags/Assistive-Touch/"}]},{"title":"UIAlertView  标题显示不出来","date":"2016-10-10T03:28:00.000Z","path":"2016/10/10/UIAlertView  标题显示不出来/","text":"最近做项目的时候，遇到一个问题，就是UIAlterView 设置了标题，但是标题一直显示不出来，但是单独出来自己写个demo,进行测试，又没问题，找了挺久的终于找到原因，因此这边记录一下，方便以后查看，也希望能帮助有遇到此问题的朋友。 这个问题是由于在UIViewController类别里面重写了系统的- (void)setTitle:(NSString*)title方法导致的。 一.UIAlertView显示不出标题123456789101112131415161718#import\"ViewController.h\"@implementationUIViewController (Extention)- (void)setTitle:(NSString*)title&#123;&#125;@end@interfaceViewController()@end@implementationViewController- (void)viewDidLoad &#123;[superviewDidLoad];UIAlertView*alterView = [[UIAlertViewalloc]initWithTitle:@\"提示\"message:@\"大家 好!\"delegate:nilcancelButtonTitle:@\"取消\"otherButtonTitles:@\"确定\",nil];[alterViewshow];self.view.backgroundColor= [UIColorwhiteColor];&#125;@end 程序运行效果: UIAlterView–无标题 二.注释掉-(void)setTitle:(NSString *)title,标题显示出来12345678910111213141516#import\"ViewController.h\"@implementationUIViewController (Extention)//- (void)setTitle:(NSString *)title&#123;////&#125;@end@interfaceViewController()@end@implementationViewController- (void)viewDidLoad &#123;[superviewDidLoad];UIAlertView*alterView = [[UIAlertViewalloc]initWithTitle:@\"提示\"message:@\"大家好!\"delegate:nilcancelButtonTitle:@\"取消\"otherButtonTitles:@\"确定\",nil];[alterViewshow];self.view.backgroundColor= [UIColorwhiteColor];&#125;@end 程序运行效果: UIAlterView–有标题 三.最后:送上一直自己挺喜欢的图片: 至于具体原因，我百度了下也没有官方说法，在这里就不误导大家，大家可以去了解下，然后跟我说下，大家相互进步。gitHub链接地址和简书链接大家有兴趣可以看一下，如果觉得不错，麻烦给个喜欢或star,如果有问题请及时反馈，谢谢！","tags":[{"name":"UIAlertView","slug":"UIAlertView","permalink":"//fjf.com/tags/UIAlertView/"},{"name":"标题","slug":"标题","permalink":"//fjf.com/tags/标题/"}]},{"title":"SDWebImage 剖析笔记","date":"2016-09-06T07:17:00.000Z","path":"2016/09/06/SDWebImage 笔记/","text":"项目中一直都有使用SDWebImage，对这个框架有一定的了解，但是体系却未能贯通，因此特地整理下,主要参考: iOS 源代码分析 — SDWebImage SDWebImage源码剖析（－） SDWebImage源码剖析（二） 一、简介:SDWebImage是一个异步下载图片并且支持缓存的UIImageView分类。主要逻辑为: 查看缓存，如果缓存中存在图片就返回图片并且更新UIImageView. 缓存中不存在图片就异步下载图片，加入缓存，更新UIImageView. 具体流程图: SDWebImage实现流程图# 二.架构简介:A.架构图:SDWebImageView_relationship UIImageView+WebCaceh和UIButton+WebCache直接为UIkit框架提供接口，而SDWebImageManger负责处理和协调SDWebImageDownloader和SDWebImageCache.并与UIkit层进行交互。 三、具体分析:1.UIImageView+WebCacheA.框架常用入口123456789// 所有设置图片最终都会调用这个方法- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder &#123; [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];&#125; 该接口调用下面这个方法: [self sd_setImageWithURL:placeholderImage:options:progress:completed:]该方法作为sd_setImageWithURL接口的最终入口，提供了多种参数。 url：远程图片的地址 placeholder : 预显示图片 options ：SDWebImageOptions 123456789101112131415161718192021222324252627282930313233343536typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; //下载失败了会再次尝试下载 SDWebImageRetryFailed = 1 &lt;&lt; 0,//当UIScrollView等正在滚动时，延迟下载图片（放置scrollView滚动卡） WebImageLowPriority = 1 &lt;&lt; 1,//只缓存到内存中SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, // 图片会边下边显示SDWebImageProgressiveDownload = 1 &lt;&lt; 3, // 将硬盘缓存交给系统自带的NSURLCache去处理 SDWebImageRefreshCached = 1 &lt;&lt; 4,//后台下载 SDWebImageContinueInBackground = 1 &lt;&lt; 5,// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie SDWebImageHandleCookies = 1 &lt;&lt; 6,// 允许不受信任的SSL证书。主要用于测试目的。 SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,// 默认情况下,image在装载的时候是按照他们在队列中的顺序装载的(就是先进先出).这个flag会把他们移动到队列的前端,并且立刻装载,而不是等到当前队列装载的时候再装载SDWebImageHighPriority = 1 &lt;&lt; 8, // 默认情况下,占位图会在图片下载的时候显示.这个flag开启会延迟占位图显示的时间,等到图片下载完成之后才会显示占位图SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, // 是否transform图片SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,&#125;;- progress ：下载进度 B.代码分析:操作的管理:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123; // 取消当前下载操作 [self sd_cancelCurrentImageLoad]; // 动态添加属性 objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);// 如果选项非SDWebImageDelayPlaceholder if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123;// 设置占位图 self.image = placeholder; &#125;); &#125; if (url.absoluteString.length &gt; 0) &#123; // check if activityView is enabled or not if ([self showActivityIndicatorView]) &#123;// 显示 下载转圈 [self addActivityIndicator]; &#125; __weak __typeof(self)wself = self; id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;// 下载完成回调// 移除下载进度转圈 [wself removeActivityIndicator]; if (!wself) return; dispatch_main_sync_safe(^&#123; if (!wself) return; if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123; completedBlock(image, error, cacheType, url); return; &#125; else if (image) &#123; wself.image = image; [wself setNeedsLayout]; &#125; else &#123; if ((options &amp; SDWebImageDelayPlaceholder)) &#123; wself.image = placeholder; [wself setNeedsLayout]; &#125; &#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125; &#125;); &#125;]; [self sd_setImageLoadOperation:operation forKey:@\"UIImageViewImageLoad\"]; &#125; else &#123; dispatch_main_async_safe(^&#123; [self removeActivityIndicator]; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @\"Trying to load a nil url\"&#125;]; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125;&#125; [self sd_cancelCurrentImageLoad];取消当前的下载操作，它表明 SDWebImage 管理操作的方法：SDWebImage所有的操作实际都是通过一个 operationDictionary 的字典管理，这个字典是动态添加到 UIView 上的一个属性，因为这个 operationDictionary 需要在UIButton 和 UIImageView 上重用，所以需要添加到它们的根类上。 这行代码是要保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突, 它会调用: 123// UIImageView+WebCache// sd_cancelCurrentImageLoad #1[self sd_cancelImageLoadOperationWithKey:@\"UIImageViewImageLoad\"] 这行代码会取消当前这个UIImageView的所有操作，不会影响之后进行的下载操作。 占位图的实现:1234// UIImageView+WebCache//sd_setImageWithURL:placeholderImage:options:progress:completed: #4if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; self.image = placeholder;&#125; 当options中没有SDWebImageDelayPlaceholder，UIImageView添加一个占位图image. 获取图片:12345678// UIImageView+WebCache// sd_setImageWithURL:placeholderImage:options:progress:completed: #8if (url)检测传入的URL是否为空，如果非空就调用全局的SDWebImageManager来获取图片:[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]下载完成后调用(SDWebImageCompletionWithFinishedBlock)completedBlock 为 UIImageView.image 赋值, 添加上最终所需要的图片. 1234567891011121314151617181920// UIImageView+WebCache//sd_setImageWithURL:placeholderImage:options:progress:completed: #10dispatch_main_sync_safe(^&#123;if (!wself) return; if (image) &#123; wself.image = image; [wself setNeedsLayout]; &#125; else &#123; if ((options &amp; SDWebImageDelayPlaceholder)) &#123; wself.image = placeholder;[wself setNeedsLayout]; &#125;&#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125;&#125;); 最后在返回 operation的同时, 也会向 operationDictionary中添加一个键值对, 来表示操作的正在进行: 1234// UIImageView+WebCachesd_setImageWithURL:placeholderImage:options:progress:completed: #28[self sd_setImageLoadOperation:operation forKey:@\"UIImageViewImageLoad\"]; 它将operation 存储到operationDictionary 中方便以后的cancel操作。 2.SDWebImageManager这个类主要用于处理异步下载和图片缓存的类，也可以直接用SDWebImageManager的downloadImageWithURL:options:progress:completed:来直接下载图片。可以看出这个类主要作用就是为了UIImageView+WebCache 和 SDWebImageDownloader, SDImageCache之间构建一个桥梁，使它们能够更好的协同工作。 A.核心代码分析:a.SDWebImageManager 123456789// SDWebImageManager// downloadImageWithURL:options:progress:completed: if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url];&#125;if (![url isKindOfClass:NSURL.class]) &#123; url = nil;&#125; 这块代码的功能是确定 url是否被正确传入, 如果传入参数的是 NSString类型就会被转换为 NSURL, 如果转换失败, 那么url 会被赋值为空, 这个下载的操作就会出错. b.SDWebImageCombinedOperation当 url 被正确传入之后, 会实例一个非常奇怪的 “operation”, 它其实是一个遵循 SDWebImageOperation 协议的 NSObject的子类. 而这个协议也非常的简单: 123@protocol SDWebImageOperation &lt;NSObject&gt;- (void)cancel;@end SDWebImageOperation只是看着像NSOperation但是它唯一跟NSOperation相同就是都可以响应cancel方法。调用这个类的cancel方法，会使得它持有的两个operation都被cancel。 12345678910111213// SDWebImageCombinedOperation// cancel #1- (void)cancel &#123; self.cancelled = YES; if (self.cacheOperation) &#123; [self.cacheOperation cancel]; self.cacheOperation = nil; &#125; if (self.cancelBlock) &#123;self.cancelBlock(); _cancelBlock = nil; &#125;&#125; 既然获取了url，再通过url获取对应的key 1NSString *key = [self cacheKeyForURL:url]; 接着通过key在缓存中查找一起是否下载过相同的图片 1operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123; ... &#125;]; 这里调用SDImageCache的实例方法 queryDiskCacheForKey:done:来尝试在缓存中获取图片的数据,而这个方法获取的就是货真价实的NSOperation.如果我们在缓存中查找到对应的图片，那么我们直接调用completedBlock回调块结束这一次图片的下载操作 123// SDWebImageManager// downloadImageWithURL:options:progress:completed: #47dispatch_main_sync_safe(^&#123; completedBlock(image, nil, cacheType, YES, url);&#125;); 如果没有找到就调用SDWebImageDownLoader的实例方法去下载该图片: 1id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123; ... &#125;]; 如果这个方法返回正确的 downloadedImage ，那么我们就在全局缓存中存储这个图片的数据: 1[self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk]; 并调用completedBlock对UIImageView或者UIButton添加图片。 最后我们将这个subOperation 的 cancel 操作添加到operation.cancelBlock 中，方便操作的取消 1operation.cancelBlock = ^&#123; [subOperation cancel]; &#125; 3.SDWebImageCache维护了一个内存缓存和一个可选的磁盘缓存,首先看下查询图片缓存的方法: 1- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock; 该方法主要功能是异步查询图片缓存，先在内存中查找 12345678// SDWebImageCache// queryDiskCacheForKey:done: #9UIImage *image = [self imageFromMemoryCacheForKey:key];// 内存中查找图片- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123; return [self.memCache objectForKey:key];&#125; imageFromMemoryCacheForKey:key 方法会在SDWebImageCache 维护的缓存 memCache 中查找是否有对应的数据，而 memCache 就是一个 NSCache. 如果在内存中没有找到图片的缓存的话，就需要在磁盘中查找。 1234567891011121314- (UIImage *)diskImageForKey:(NSString *)key &#123; NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; UIImage *image = [UIImage sd_imageWithData:data];image = [self scaledImageForKey:key image:image]; if (self.shouldDecompressImages) &#123; image = [UIImage decodedImageWithImage:image]; &#125; return image; &#125; else &#123; return nil; &#125;&#125; 得到图片对应的NSData后还有经过: 根据图片的不同种类，生成对应的UIImage, 根据key值，调整image的Scale值 如果设置图片需要解压缩，需要对图片进行解码 对图片进行存储需要对url进行MD5加密计算生成相应的key值: 12345678910111213- (NSString *)cachedFileNameForKey:(NSString *)key &#123; const char *str = [key UTF8String]; if (str == NULL) &#123; str = \"\"; &#125; unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSString *filename = [NSString stringWithFormat:@\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@\", r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@\"\"] ? @\"\" : [NSString stringWithFormat:@\".%@\", [key pathExtension]]]; return filename;&#125; 然后用该key作为图片文件名存储在默认路径下: 12345678910111213// 获取缓存路径方法(自己写的)- (NSString*)getCachePath &#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); if (paths.count &gt; 0) &#123; NSString *path = [paths[0] stringByAppendingFormat:@\"/com.hackemist.SDWebImageCache.default\"]; if (![[NSFileManager defaultManager] fileExistsAtPath:path]) &#123; [[NSFileManager defaultManager] createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil]; &#125; return path; &#125;else&#123; return nil; &#125;&#125; 之前做朋友圈后台发送图片就是先将小图命名，然后根据获取到的七牛的domain和token,拼出url，接着将该url，进行md5加密，加密后存储到SDWebImage 的默认存储路径下，然后在主界面显示存储的小图，后台去进行图片压缩上传任务。 12345 UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; 如果在磁盘中找到图片，就将他复制到内存中，以便下次使用。 4.SDWebImageDownloader专用的并且优化的图片异步下载器,主要用来下载图片,下载放在NSOperationQueue中进行，默认maxConcurrentOperationCount为6，timeout时间为15s. 1- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock 该方法直接调用了下载进度回调函数: 1234567891011121314151617181920212223242526272829- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123; // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return; &#125; dispatch_barrier_sync(self.barrierQueue, ^&#123; BOOL first = NO; if (!self.URLCallbacks[url]) &#123; self.URLCallbacks[url] = [NSMutableArray new]; first = YES; &#125; // Handle single download of simultaneous download request for the same URL NSMutableArray *callbacksForURL = self.URLCallbacks[url]; NSMutableDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; [callbacksForURL addObject:callbacks]; self.URLCallbacks[url] = callbacksForURL; if (first) &#123; createCallback(); &#125; &#125;);&#125; 方法会先查看这个 url是否有对应的 callback, 使用的是 downloader，持有的一个字典 URLCallbacks.如果是第一次添加回调的话, 就会执行 first = YES, 这个赋值非常的关键, 因为 first不为 YES那么 HTTP 请求就不会被初始化, 图片也无法被获取.然后, 在这个方法中会重新修正在 URLCallbacks中存储的回调块. 通过dispatch_barrier_async函数提交的任务会等它前面的任务执行完才开始，然后它后面的任务必须等它执行完毕才能开始. 必须使用dispatch_queue_create创建的队列才会达到上面的效果.通过该函数来保证每张图片进度顺序。 如果是第一次添加回调块，那么就会直接运行这个createCallBack这个block，而这个block，就是我们在downloadImageWithURL:options:progress:completed: 中传入的回调块. 接着分析下NSMutableURLRequest请求: 1 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; 该request 发送了一个http请求，接着又初始化一个SDWebImageDownloaderOperation实例，这个实例用于请求网络资源的操作，是NSOperation的子类: 123operation = [[wself.operationClass alloc] initWithRequest:request options:options progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; 初始化之后，将该operation添加到NSOperationQueue中。(备注:NSOperation实例只有在调用start方法或者加入NSOperationQueue 才会执行) 1[wself.downloadQueue addOperation:operation]; 5.SDWebImageDownloaderOperation这个类主要处理HTTP请求，URL连接的类，当这个类的实例被加入到队列之后，start方法被调用，start方法首先产生一个NSURLConnection,，通过NSURLConnection进行图片的下载，为了确保能够处理下载的数据，需要在后台运行runloop,保证程序不被挂起. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576- (void)start &#123; @synchronized (self) &#123; if (self.isCancelled) &#123; self.finished = YES; [self reset]; return; &#125;#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0 Class UIApplicationClass = NSClassFromString(@\"UIApplication\"); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123; __weak __typeof__ (self) wself = self; UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123; __strong __typeof (wself) sself = wself; if (sself) &#123; [sself cancel]; [app endBackgroundTask:sself.backgroundTaskId]; sself.backgroundTaskId = UIBackgroundTaskInvalid; &#125; &#125;]; &#125;#endif self.executing = YES; self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO]; self.thread = [NSThread currentThread]; &#125; [self.connection start]; if (self.connection) &#123; if (self.progressBlock) &#123; self.progressBlock(0, NSURLResponseUnknownLength); &#125;//在主线程发通知，这样也保证在主线程收到通知 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self]; &#125;); if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) &#123; // Make sure to run the runloop in our background thread so it can process downloaded data // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5 // not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466) CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false); &#125; else &#123; CFRunLoopRun(); &#125; if (!self.isFinished) &#123; [self.connection cancel]; [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]]; &#125; &#125; else &#123; if (self.completedBlock) &#123; self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @\"Connection can't be initialized\"&#125;], YES); &#125; &#125;#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0 Class UIApplicationClass = NSClassFromString(@\"UIApplication\"); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123; UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)]; [app endBackgroundTask:self.backgroundTaskId]; self.backgroundTaskId = UIBackgroundTaskInvalid; &#125;#endif&#125; 接下来这个 connection 就会开始运行: 1[self.connection start]; 它发出一个SDWebImageDownloadStartNotification通知,开启状态栏的请求加载转圈。同时调用NSURLConnectionDataDelegate代理 123- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection; 前两个代理会不停的回调 pregressBlock 来提示下载进度。 而最后一个代理方法会在图片下载完成之后调用completionBlock 来完成最后 UIImageView.image的更新，而这里调用的 progressBlock，completionBlock， cancelBlock 都是在之前存储在 URLCallbacks字典中的. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection &#123; SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock; @synchronized(self) &#123;// 停止 该线程 运行时 CFRunLoopStop(CFRunLoopGetCurrent()); self.thread = nil; self.connection = nil;// 通知停止状态栏转圈请求 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self]; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:self]; &#125;); &#125; if (![[NSURLCache sharedURLCache] cachedResponseForRequest:_request]) &#123; responseFromCached = NO; &#125; if (completionBlock) &#123; if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached) &#123; completionBlock(nil, nil, nil, YES); &#125; else if (self.imageData) &#123;// 进行缓存 UIImage *image = [UIImage sd_imageWithData:self.imageData]; NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL]; image = [self scaledImageForKey:key image:image]; // Do not force decoding animated GIFs if (!image.images) &#123;// 进行解码 if (self.shouldDecompressImages) &#123; image = [UIImage decodedImageWithImage:image]; &#125; &#125; if (CGSizeEqualToSize(image.size, CGSizeZero)) &#123; completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @\"Downloaded image has 0 pixels\"&#125;], YES); &#125; else &#123; completionBlock(image, self.imageData, nil, YES); &#125; &#125; else &#123; completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @\"Image data is nil\"&#125;], YES); &#125; &#125; self.completionBlock = nil; [self done];&#125; 转换处理图片和进行缓存后，将下载image赋值给控件。 四:最后送上一张自己喜欢的图片: 个人小结，有兴趣的朋友可以看一下，这是简书链接如果觉得不错，麻烦给个喜欢或star,若发现问题请及时反馈，谢谢！","tags":[{"name":"SDWebImage","slug":"SDWebImage","permalink":"//fjf.com/tags/SDWebImage/"},{"name":"流程","slug":"流程","permalink":"//fjf.com/tags/流程/"},{"name":"剖析","slug":"剖析","permalink":"//fjf.com/tags/剖析/"}]},{"title":"UINavigationBar和UITabBar 上滚渐变显示 下拉渐变隐藏","date":"2016-08-18T07:49:00.000Z","path":"2016/08/18/UINavigationBar和UITabBar 上滚渐变显示 下拉渐变隐藏/","text":"由于项目需求要做一个这样的功能，所以做好之后，抽取出来，封装了下，希望能帮到有需要的朋友。 一.效果图 UINavigationBar和UITabbar渐变.gif 二.思路 A. 设置tableView a.因为当UINavigationBar和UITabBar隐藏的时候，tableView要完全占据整个屏幕，当UINavigationBar和UITabBar显示的时候，tableView又要显示在UINavigationBar下方，所以需要设置tablewView的frame和contentInset： 123self.tableView.frame = CGRectMake(0, -kNavigationBarHeight,kScreenWidth,kScreenHeight+kNavigationBarHeight);self.tableView.contentInset = UIEdgeInsetsMake(kNavigationBarHeight,0,0,0); B.设置UINavigationBar和UITabBar的位移 当tableView向上移动一个属性,UINavigationBar要向上移动一个属性，UITabBar要向下移动一个像素，所以需要在- (void)scrollViewDidScroll:(UIScrollView*)scrollView方法中获取每一次tableView滚动的距离，因此需要记住上次tableView的偏移量距离： 12345678910111213141516CGFloat_originalOffsetY;//上一次偏移量CGFloat offsetY = scrollView.contentOffset.y-_originalOffsetY;//获取每次滚动偏移的距离 _originalOffsetY = scrollView.contentOffset.y;//将这次tableView偏移量重新赋值给_originalOffsetY ~~~ 又因为当UINavigationBar和UITabBar已经隐藏，继续向上滚动，已经不需要隐藏，同样的当tableView滚动到最后滚不动的时候UINavigationBar和UITabBar也不需要移动，所以添加判断条件~~~ //判断是否滚动到底部CGFloat bottomOffset = scrollView.contentSize.height - scrollView.contentOffset.y - scrollView.frame.size.height; //判断UINavigationBar是否已经隐藏scrollView.contentOffset.y &gt; - (2*kNavigationBarHeight) 12345678910111213// UIScrollView 代理- (void)scrollViewDidScroll:(UIScrollView*)scrollView &#123; CGFloat bottomOffset = scrollView.contentSize.height- scrollView.contentOffset.y- scrollView.frame.size.height; if(scrollView.contentOffset.y&gt; - kNavigationBarHeight &amp;&amp; bottomOffset &gt;0) &#123; CGFloat offsetY = scrollView.contentOffset.y-_originalOffsetY; [self moveNavigationBarAndStatusBarByOffsetY:offsetY]; &#125; _originalOffsetY= scrollView.contentOffset.y;&#125; C.设置UINavigationBar和UITabBar相关transform.ty moveNavigationBarAndStatusBarByOffsetY函数设置UINavigationBar和UITabBar相关transform.ty位置的值，同时设置相关背景图片的透明度 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 通过偏移量移动NavigationBar和StatusBar- (void)moveNavigationBarAndStatusBarByOffsetY:(CGFloat)offsetY &#123; CGFloat transformTy = self.navigationController.navigationBar.transform.ty; CGFloat tabbarTransformTy = self.tabBarController.tabBar.transform.ty; // 向上滚动 if (offsetY &gt; 0) &#123; if (fabs(transformTy) &gt;= kNavigationBarHeight) &#123; //当NavigationBar的transfrom.ty大于NavigationBar高度，导航栏离开可视范围，设置NavigationBar隐藏 [self setNavigationBarTransformProgress:1 navigationBarStatusType:NavigationBarStatusOfTypeHidden]; &#125; else &#123; //当NavigationBar的transfrom.ty小于NavigationBar高度，导航栏在可视范围内，设置NavigationBar偏移位置和背景透明度 [self setNavigationBarTransformProgress:offsetY navigationBarStatusType:NavigationBarStatusOfTypeNormal]; &#125; if (fabs(tabbarTransformTy) &gt;= kStatusBarHeight) &#123; //当StatusTabBar的transfrom.ty大于StatusTabBar高度，导航栏离开可视范围，设置StatusTabBar隐藏 [self setStatusBarTransformProgress:1 statusBarStatusType:StatusBarStatusTypeOfHidden]; &#125; else &#123; //当当StatusTabBar的transfrom.ty小于StatusTabBar高度，导航栏在可视范围内，设置StatusTabBar偏移位置和背景透明度 [self setStatusBarTransformProgress:offsetY statusBarStatusType:StatusBarStatusTypeOfNormal]; &#125; // 向下滚动 &#125; else if(offsetY &lt; 0)&#123; if (transformTy &lt; 0 &amp;&amp; fabs(transformTy) &lt;= kNavigationBarHeight) &#123; //当NavigationBar的transfrom.ty小于NavigationBar高度，导航栏进入可视范围内，设置NavigationBar偏移位置和背景透明度 [self setNavigationBarTransformProgress:offsetY navigationBarStatusType:NavigationBarStatusOfTypeNormal]; &#125; else &#123; //当NavigationBar的transfrom.ty超过NavigationBar原来位置，设置NavigationBar显示 [self setNavigationBarTransformProgress:0 navigationBarStatusType:NavigationBarStatusOfTypeShow]; &#125; if (tabbarTransformTy &lt;= kStatusBarHeight &amp;&amp; tabbarTransformTy &gt; 0) &#123; //当StatusTabBar的transfrom.ty小于StatusTabBar高度，导航栏进入可视范围内，设置StatusTabBar偏移位置和背景透明度 [self setStatusBarTransformProgress:offsetY statusBarStatusType:StatusBarStatusTypeOfNormal]; &#125; else &#123; //当StatusTabBar的transfrom.ty超过StatusTabBar原来位置，设置StatusTabBar显示 [self setStatusBarTransformProgress:0 statusBarStatusType:StatusBarStatusTypeOfShow]; &#125; &#125;&#125; D. UINavigationBar和UITabBar背景图透明度和颜色通过这两个函数来改变UINavigationBar和UITabBar背景图透明度和颜色: 12345678910111213141516171819// 根据传入的类型和渐变程度,改变StatusBar的颜色和位置- (void)setStatusBarTransformProgress:(CGFloat)progress statusBarStatusType: (StatusBarStatusType)statusBarStatusType&#123; CGFloat transfromTy = self.tabBarController.tabBar.transform.ty; if (statusBarStatusType == StatusBarStatusTypeOfHidden) &#123; if (transfromTy != kStatusBarHeight) &#123; [self.tabBarController.tabBar fj_moveByTranslationY:kStatusBarHeight * progress]; [self.tabBarController.tabBar fj_setImageViewAlpha:progress]; &#125; &#125;else if(statusBarStatusType == StatusBarStatusTypeOfNormal) &#123; [self.tabBarController.tabBar fj_setTranslationY:-progress]; CGFloat alpha = 1 - fabs(self.tabBarController.tabBar.transform.ty)/kStatusBarHeight; [self.tabBarController.tabBar fj_setImageViewAlpha:alpha]; &#125;else if(statusBarStatusType == StatusBarStatusTypeOfShow) &#123; if (transfromTy != 0) &#123; [self.tabBarController.tabBar fj_moveByTranslationY: -kStatusBarHeight * progress]; [self.tabBarController.tabBar fj_setImageViewAlpha:(1-progress)]; &#125; &#125;&#125; 12345678910111213141516171819// 根据传入的类型和渐变程度,改变NavigationBar的颜色和位置- (void)setNavigationBarTransformProgress:(CGFloat)progress navigationBarStatusType:(NavigationBarStatusType)navigationBarStatusType&#123; CGFloat transfromTy = self.navigationController.navigationBar.transform.ty; if (navigationBarStatusType == NavigationBarStatusOfTypeHidden) &#123; if(transfromTy != -kNavigationBarHeight)&#123; [self.navigationController.navigationBar fj_moveByTranslationY:-kNavigationBarHeight * progress]; [self.navigationController.navigationBar fj_setImageViewAlpha:progress]; &#125; &#125;else if(navigationBarStatusType == NavigationBarStatusOfTypeNormal) &#123; [self.navigationController.navigationBar fj_setTranslationY: - progress]; CGFloat alpha = 1 - fabs(self.navigationController.navigationBar.transform.ty)/kNavigationBarHeight; [self.navigationController.navigationBar fj_setImageViewAlpha:alpha]; &#125;else if(navigationBarStatusType == NavigationBarStatusOfTypeShow) &#123; if(transfromTy != 0)&#123; [self.navigationController.navigationBar fj_moveByTranslationY:-kNavigationBarHeight * progress]; [self.navigationController.navigationBar fj_setImageViewAlpha:(1-progress)]; &#125; &#125;&#125; E.设置UITabBar和UINavigationBar类方法 // 设置背景图透明度 - (void)fj_setImageViewAlpha:(CGFloat)alpha; // 根据translationY在原来位置上偏移 - (void)fj_setTranslationY:(CGFloat)translationY; // 设置偏移translationY - (void)fj_moveByTranslationY:(CGFloat)translationY; F.停止时刻处理 在- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate函数里面判断当前NavigationBar偏移是否超过一半，如果一半则动画隐藏，如果没有则动画显示: 1234567891011121314151617//恢复或隐藏navigationBar和statusBar- (void)restoreNavigationBarAndStatusBarWithContentOffset:(CGPoint)contentOffset &#123; CGFloat navigationBarCenterHeight = kNavigationBarHeight/2.0; CGFloat transformTy = self.navigationController.navigationBar.transform.ty; if (transformTy &lt; 0 &amp;&amp; transformTy &gt; -kNavigationBarHeight) &#123; if (transformTy &lt; -navigationBarCenterHeight &amp;&amp; contentOffset.y &gt; -navigationBarCenterHeight) &#123; [UIView animateWithDuration:kDefaultAnimationTime animations:^&#123; [self hideNavigationBarAndStatusBar]; &#125;]; &#125; else &#123; [UIView animateWithDuration:kDefaultAnimationTime animations:^&#123; [self showNavigationBarAndStatusBar]; &#125;]; &#125; &#125;&#125; 三.最后:送上我最喜欢之一的动漫图: 这是gitHub链接和简书地址，大家有兴趣可以看一下，如果觉得不错，麻烦给个喜欢或星，谢谢！","tags":[{"name":"IOS","slug":"IOS","permalink":"//fjf.com/tags/IOS/"},{"name":"动画","slug":"动画","permalink":"//fjf.com/tags/动画/"},{"name":"UINavigationBar","slug":"UINavigationBar","permalink":"//fjf.com/tags/UINavigationBar/"},{"name":"UITabBar","slug":"UITabBar","permalink":"//fjf.com/tags/UITabBar/"}]}]