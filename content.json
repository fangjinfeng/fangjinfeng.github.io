[{"title":"Runtime (整理笔记)","date":"2017-01-21T16:00:00.000Z","path":"2017/01/22/Runtime(整理笔记)/","text":"说明:此文是自己的总结笔记，主要参考这几篇文章:iOS开发-Runtime详解NSHipster里面的这两篇文章 :Associated ObjectsMethod Swizzling #一.Runtime简介 Runtime又叫运行时，是一套底层的C语言API,其为IOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。比如: [receiver doSomething];底层运行会被编译器转化为:objc_msgSend(receiver, @selector(doSomething))如果带有参数比如:[receiver doSomething:(id)arg…];底层运行时会被编译器转化为:objc_msgSend(receiver, @selector(doSomething), arg1, arg2, …)可能通过以上你看不出它的价值，但是我们需要了解OC是一门动态语言，它会将一些工作放在代码运行时才处理而非在编译的时候，也就是说，有很多类和成员变量在我们编译的时候是不知道的，而在运行时，我们所编写的代码会转换成完整的代码运行。因此，编译器是不够，我们还需要一个运行时的系统来处理编译后的代码 Runtime 基本是C和汇编写的，可以充分保证动态系统的高效性 #二. Runtime的作用: 获取某个类的所有成员变量 获取某个类的所有属性 获取某个类的所有方法 交换方法实现 动态添加一个成员变量 动态添加一个方法 #三.Runtime的术语的数据结构 1.SEL 它是selector在objc中的表示(Swift 中是 Selector类)。selector 是方法选择器，其实作用是对方法名进行包装，一遍找到对应的方法实现(注意:Objc 在相同的类中不会有命名相同的两个方法)。 对应的数据结构:typedef struct objc_selector *SEL;我们可以看出它是个映射到方法的C字符串，你可以通过Objc编译器命令@selector()或者Runtime系统的sel_registerName函数来获取一个SEL类型的方法选择器。 注意:不同类中相同名字的方法所对应的selector是相同的，由于变量的类型不同(即实例变量所对应的类的类型不同如NSString、NSMutableString等类型不同)，所以不会导致它们调用方法实现的混乱。 2.idid 是一个参数类型，它是指向某个类的实例的指针。定义如下: typedef struct objc_object *id;struct objc_object { Class isa; };通过以上定义，可以看到:objc_object结构体包含一个isa指针，根据isa指针就可以找到对象所属的类。 注意:isa指针在代码运行时并不总是指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型需要用对象的 - class方法。 3.Class typedef struct objc_class *Class;Class 其实是指向 objc_class 结构体的指针。objc_class的数据结构如下: struct objc_class {Class isa;//指针，顾名思义，表示是一个什么，//实例的isa指向类对象，类对象的isa指向元类 #if !OBJC2Class super_class; //指向父类const char name; //类名long version; // 类的版本信息，初始化默认为0，可以通过runtime函数class_setVersion和class_getVersion进行修改、读取long info; // 一些标识信息,如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;long instance_size; // 该类的实例变量大小(包括从父类继承下来的实例变量);struct objc_ivar_list ivars // 成员变量列表struct objc_method_list *methodLists; // 方法列表struct objc_cache cache;// 缓存,存储最近使用的方法指针，用于提升效率struct objc_protocol_list *protocols // 协议列表 #endif} OBJC2_UNAVAILABLE;/ Use Class instead of `struct objc_class ` */从结构体可以看出，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。其中objc_ivar_list和objc_method_list 分别是成员变量列表和方法列表: // 成员变量列表struct objc_ivar_list {int ivar_count OBJC2_UNAVAILABLE; #ifdef LP64int space OBJC2_UNAVAILABLE; #endif/ variable length structure /struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;} OBJC2_UNAVAILABLE; // 方法列表struct objc_method_list {struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE; #ifdef LP64int space OBJC2_UNAVAILABLE; #endif/ variable length structure /struct objc_method method_list[1] OBJC2_UNAVAILABLE;}我们都知道，OC中一切都被设计成对象，一个类被初始化成一个实例，这个实例是一个对象。实际上一个类的本质也是一个对象，在runtime中用如上结构体表示。关于isa指针: 比如 : NSString *tmpStr = [NSString string];这里的tmpStr的isa指针指向类对象NSString,而NSString的isa指针指向元类NSObject. 4. MethodMethod 代表类中某个方法的类型 typedef struct objc_method *Method; struct objc_method {SEL method_name OBJC2_UNAVAILABLE;char *method_types OBJC2_UNAVAILABLE;IMP method_imp OBJC2_UNAVAILABLE;}objc_method存储了方法名、方法类型和方法实现: 方法名类型为SEL 方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型 method_imp 指向了方法的实现，本质是一个函数指针 5.IvarIvar 是成员变量的类型。 typedef struct objc_ivar *Ivar; struct objc_ivar {char ivar_name // 变量名称;char ivar_type // 变量类型;int ivar_offset // 基地址偏移字节; #ifdef LP64int space // 大小; #endif}其中 ivar_offset 是基地址偏移字节 6.IMPIMP在objc.h中的定义是:typedef id (*IMP)(id, SEL, …);它是一个函数指针，这是由编译器生成的。当你发送一个objc消息之后，最终它会执行那段代码，就是由这个函数指针指定的。而IMP这个函数指针就指向了这个方法的实现。 我们发现IMP指向的方法和objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的实现方法地址。所以一个确定的方法也只有一组id和SEL参数:比如: NSString *tmpStr = [NSString string];BOOL isContain = [tmpStr containsString:@”1”];这里的containsString的实现方法就是由id(NSString)和SEL参数(containsString)确定的。 7.Cache typedef struct objc_cache *Cache struct objc_cache {unsigned int mask / total = mask + 1 / OBJC2_UNAVAILABLE;unsigned int occupied OBJC2_UNAVAILABLE;Method buckets[1] OBJC2_UNAVAILABLE;};Cache主要用来提高查找效率，当一个方法被调用，首先在Cache列表中查找，如果找到直接返回，如果没有找到，再到类的方法列表去查找，找到了将该方法返回同时存入缓存列表。 8.Property typedef struct objc_property Property;typedef struct objc_property objc_property_t;//这个更常用 可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性： objc_property_t class_copyPropertyList(Class cls, unsigned int outCount)objc_property_t protocol_copyPropertyList(Protocol proto, unsigned int *outCount) 注意返回的是属性列表，列表中的每个元素都是一个objc_property_t指针 总结: // 描述类中的一个方法typedef struct objc_method *Method; // 实例变量typedef struct objc_ivar *Ivar; // 缓存(类方法)typedef struct objc_cache *Cache； // 实现 方法typedef id (*IMP)(id, SEL, …); // 类别Categorytypedef struct objc_category *Category; // 类中声明的属性typedef struct objc_property *objc_property_t; #四.获取列表有时候会有这样的需求，我们需要知道当前类中每个属性的名字(比如字典转模型，字典的key和模型对象的属性名字不匹配)。我们可以通过runtime的一系列方法获取类的一些信息(包括属性列表、方法列表、成员变量列表和遵循的协议列表) unsigned int count;//获取属性列表objc_property_t propertyList = class_copyPropertyList([self class], &amp;count);for (unsigned int i=0; i&lt;count; i++) {const char propertyName = property_getName(propertyList[i]);NSLog(@”property—-&gt;%@”, [NSString stringWithUTF8String:propertyName]);} //获取方法列表Method *methodList = class_copyMethodList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) {Method method = methodList[i];NSLog(@”method—-&gt;%@”, NSStringFromSelector(method_getName(method)));} //获取成员变量列表Ivar ivarList = class_copyIvarList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) {Ivar myIvar = ivarList[i];const char ivarName = ivar_getName(myIvar);NSLog(@”Ivar—-&gt;%@”, [NSString stringWithUTF8String:ivarName]);} //获取协议列表__unsafe_unretained Protocol *protocolList = class_copyProtocolList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) {Protocol myProtocal = protocolList[i];const char *protocolName = protocol_getName(myProtocal);NSLog(@”protocol—-&gt;%@”, [NSString stringWithUTF8String:protocolName]);} #五.方法调用方法调用在运行时的过程: 如果调用的是类方法，就会到类对象的isa指针指向的对象(也就是元类对象)中操作。比如:NSString *tmpStr = [NSString string];这里的 [NSString string]调用的是NSString的类方法，就会到NSString类对象的isa指针指向的对象NSObject元类中操作。 如果用实例对象调用实例方法，会到实例的isa指针指向的对象(也就是类对象)操作。比如: BOOL isContain = [tmpStr containsString:@”1”];这里的 [tmpStr containsString:@”1”],就是实例对象tmpStr调用containsString这个实例方法，得到实例tmpStr的isa指针指向的对象也就是类对象NSString操作。 NSString *tmpStr = [NSString string];BOOL isContain = [tmpStr containsString:@”1”]; 1. 首先，在相应操作对象中的缓存列表中查找调用的方法，如果找到，转向相应的实现并执行.(即先在tmpStr这个对象的缓存列表中查找是否有containsString这个方法，如果有，则转向相应的实现函数，并执行)； 2.如果没有找到，在相应操作对象的方法中找调用的方法，如果找到，转向相应的实现并执行。(即tmpStr的缓存列表找没有找到containsString这个方法，就到tmpStr的方法列表里面查找，如果找到，则转向相应的实现函数，并执行)； 3.如果没找到，去父类指针所指向的对象中执行1，2（即如果在tmpStr的方法列表里面没有找到containsString这个方法，则转向tmpStr的父类，也就是NSObject类去查找该方法） 4.以此类推，如果一直到根类都还没找到，转向拦截调用(即如果在父类NSObject里面也没有找到containsString这个方法，就往上一层父类再去查找，知道最顶层(根层)父类，因为NSObject在OC中是根层父类，所以如果在NSObjec的方法列表找没找到containsString，就转向拦截调用) 5.如果没有重写拦截调用的方法，程序报错。(即在tmpStr及其父类的方法列表中都没有containsString这个方法，就转向拦截调用，但是却没有实现拦截调用的方法，系统就报错) 所以: 重写父类的方法，并没有覆盖父类的方法，只是在当前类对象中找到了这个方法后，就不会再去父类中寻找了。 如果子类重写父类的方法，但也想调用父类方法的实现，只需使用super这个编译器标识，它会在运行时先去调用父类的方法，在执行之类的方法。比如我们很常见的viewWillAppear函数: (void)viewWillAppear:(BOOL)animated {[super viewWillAppear:animated];[self.navigationController setNavigationBarHidden:YES animated:animated];}这里的super标识，在运行时会先去执行父类的viewWillAppear方法，执行完毕之后，在回来接着执行原函数里面的隐藏导航栏的操作，如果没有 [super viewWillAppear:animated];就不会去调用父类的该方法，直接执行隐藏导航栏的操作。 #六.拦截调用拦截调用就是在找不到调用方法程序崩溃之前，你有机会通过重写NSObject的四个方法来处理，防止崩溃发生。 (BOOL)resolveClassMethod:(SEL)sel;该方法就是当你调用一个不存在的类方法的时候，会调用该方法，默认返回NO,你可以加上自己的处理然后返回YES. (BOOL)resolveInstanceMethod:(SEL)sel;这个方法和上一个方法相似，处理的是实例方法。(备注: NSString *tmpStr = [NSString string];像 [NSString string]这里的string就是类方法， [tmpStr containsString:@”1”]这里的containsString就是实例方法。) (id)forwardingTargetForSelector:(SEL)aSelector;该方法将你调用的不存在的方法重定向到一个声明了这个方法的类，只需要你返回一个有这个方法的target. (void)forwardInvocation:(NSInvocation *)anInvocation;该方法将你调用的不存在的方法打包成NSInvocation传给你。做完你自己的处理后，调用inovkeWithTarget:方法让某个target触发这个方法。 #七.动态添加方法 重写了拦截调用的方法并且返回YES,接下来可以根据传入的SEL类型的selector，动态添加一个方法。 首先从外部隐式调用一个不存在的方法: // 隐式调用方法[target performSelector:@selector(resolveAdd:) withObject:@”test”];然后，在target对象内部重写拦截调用的方法，动态添加方法 void runAddMethod(id self, SEL _cmd, NSString *string){NSLog(@”add C IMP “, string);} (BOOL)resolveInstanceMethod:(SEL)sel{//给本类动态添加一个方法if ([NSStringFromSelector(sel) isEqualToString:@”resolveAdd:”]) {class_addMethod(self, sel, (IMP)runAddMethod, “v@:*”);}return YES;} 其中class_addMethod的四个参数分别是: Class cls 给哪个类添加方法，本例中是self SEL name 添加的方法，本例中是重写拦截调用传进来的selector IMP imp 方法的实现，C方法的实现可以直接获得。如果是OC方法，可以用+(IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。 “v@:*”方法的签名，代表有一个参数的方法 #八.关联对象 比如现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。这种情况的一般解决办法就是继承。但是，只增加一个属性，就去继承一个类，总结太麻烦，这时候runtime的关联属性就发挥它的作用了。 1.首先定义一个全局变量，用它的地址作为关联对象的key static char kAssociatedObjectKey;2.在NSObject+AssociatedObject.h里面添加新的属性 NSObject+AssociatedObject.h @interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end 3.在NSObject+AssociatedObject.m里面添加设置和获取方法 //设置关联对象@implementation NSObject (AssociatedObject)@dynamic associatedObject; (void)setAssociatedObject:(id)object {objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);} //获取关联对象 (id)associatedObject {return objc_getAssociatedObject(self, @selector(associatedObject));} objc_setAssociatedObject的四个参数: id object 给谁设置关联对象 const void *key 关联对象唯一的key,获取时会用到 id value 关联的对象 objc_AssociationPolicy 关联策略,有以下几种策略: enum {OBJC_ASSOCIATION_ASSIGN = 0, // 给关联对象指定弱引用OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 给关联的对象指定非原子操作哦OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 给关联对象指定费原子的copy特性OBJC_ASSOCIATION_RETAIN = 01401, // 给关联的对象指定原子的强引用OBJC_ASSOCIATION_COPY = 01403 // 给关联的对象指定原子的copy 特性}; objc_getAssociatedObject 的两个参数: id object 获取谁的关联对象 const void *key 根据这个唯一的key获取关联对象。 其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能类的类别里面，方便调用。 //添加关联对象 (void)addAssociatedObject:(id)object{objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}//获取关联对象 (id)getAssociatedObject{return objc_getAssociatedObject(self, _cmd);} getAssociatedObject 方法的地址作为唯一的key， _cmd代表当前调用方法的地址，也就是getAssociatedObject方法的地址 注意 :4.移除关联对象:objc_removeAssociatedObjects()这个函数很容易让对象恢复成它”原始状态”，你不应该使用它来移除关联的对象，因为它也会移除包括其他地方加入的全部关联对象。所以你一般只需要通过调用objc_setAssociatedObject并传入nil值类清除关联值。 优秀样例 添加私有属性用于更好地去实现细节。当扩展一个内建类的行为时，保持附加属性的状态可能非常必要。注意以下说的是一种非常教科书式的关联对象的用例：AFNetworking在 UIImageView的category上用了关联对象来保持一个operation对象，用于从网络上某URL异步地获取一张图片。 添加public属性来增强category的功能。有些情况下这种(通过关联对象)让category行为更灵活的做法比在用一个带变量的方法来实现更有意义。在这些情况下，可以用关联对象实现一个一个对外开放的属性。回到上个AFNetworking的例子中的 UIImageViewcategory，[它的 imageResponseSerializer ](https://github.com/AFNetworking/AFNetworking/blob/2.1.0/UIKit%2BAFNetworking/UIImageView%2BAFNetworking.h#L60-L65)方法允许图片通过一个滤镜来显示、或在缓存到硬盘之前改变图片的内容。 创建一个用于KVO的关联观察者。当在一个category的实现中使用KVO时，建议用一个自定义的关联对象而不是该对象本身作观察者。 错误模式 在不必要的时候使用关联对象。使用视图时一个常见的情况是通过数据模型或一些复合的值来创建一个便利的方法设置填充字段或属性。如果这些值在后面不会再被使用到，最好就不要使用关联对象了。(比如你将自定义的UITableViewCell跟模型关联起来，但这个cell值用在一个ViewController里面，也就是说这个关联对象只用到一处，之后就不再使用，这种情况下就没必要使用关联对象)。 使用关联对象来保存一个可以被推算出来的值。例如，有人可能想通过关联对象存储UITableViewCell上一个自定义accessoryView的引用，使用tableView:accessoryButtonTappedForRowWithIndexPath: 和 cellForRowAtIndexPath:即可以达到要求。 使用关联对象来代替X。其中X代表下面的一些项：子类化，当使用继承比使用组合更合适的时候。 Target-Action给响应者添加交互事件。 手势识别，当target-action模式不够用的时候。 代理，当事件可以委托给其他对象。 消息 &amp; 消息中心使用低耦合的方式来广播消息。 #九.方法交换顾名思义:就是将两个方法的实现交换，比如，将A方法和B方法交换，调用A方法的时候，就回去执行B方法中的代码，反之亦然。参考Mattt Thompson的[Method Swizzling]文章: #import @implementation UIViewController (Tracking) (void)load {static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:);SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector);Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // When swizzling a class method, use the following:// Class class = object_getClass((id)self);// …// Method originalMethod = class_getClassMethod(class, originalSelector);// Method swizzledMethod = class_getClassMethod(class, swizzledSelector); BOOL didAddMethod =class_addMethod(class,originalSelector,method_getImplementation(swizzledMethod),method_getTypeEncoding(swizzledMethod)); if (didAddMethod) {class_replaceMethod(class,swizzledSelector,method_getImplementation(originalMethod),method_getTypeEncoding(originalMethod));} else {method_exchangeImplementations(originalMethod, swizzledMethod);}});} #pragma mark - Method Swizzling (void)xxx_viewWillAppear:(BOOL)animated {[self xxx_viewWillAppear:animated];NSLog(@”viewWillAppear: %@”, self);} @end在自己定义的viewController中重写viewWillAppear (void)viewWillAppear:(BOOL)animated {[super viewWillAppear:animated];NSLog(@”viewWillAppear”);}就会调用xxx_viewWillAppear,输出log, method swizzling在视图控制器的生命周期、响应事件、绘制视图或者Foundation框架的网络栈等方法中需要插入代码的时候，都是很好的解决方法。 +load vs +initialize: swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。 +load 是在一个类被初始装载时调用(iOS应用启动的时候，就会加载所有的类，就会调用这个方法)；并且因为加载进内存只会加载一次，所以也一般也只会调用一次 +initialize 是在应用第一次调用该类的类方法或实例方法前调用的，调用次数根据子类和具体调用情况确定。 dispatch_once: swizzling 应该只在 dispatch_once 中完成。 由于 swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 满足了所需要的需求，并且应该被当做使用 swizzling 的初始化单例方法的标准。 Selectors, Methods, &amp; Implementations苹果定义: Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。 Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。 Implementation（typedef id (*IMP)(id, SEL,…)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象metaclass）。第二个参数是这个方法的名字selector，该方法的真正参数紧随其后。 三者之间的关系: 在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。 也就是说swizzling只是交换两个方法在函数表中的指向地址而已。 调用 _cmd (void)xxx_viewWillAppear:(BOOL)animated {[self xxx_viewWillAppear:animated];NSLog(@”viewWillAppear: %@”, NSStringFromClass([self class]));}初看这段代码，我们都会觉得会出现递归死循环。但事实不是这样的: method swizzling 在交换方法的实现后，xxx_viewWillAppear:方法的实现已经被替换为UIViewController 的-viewWillAppear：这个原生方法。 所以当我们在UIViewController调用这个- (void)viewWillAppear:(BOOL)animated 方法的时候，实际上调用的是xxx_viewWillAppear这个方法，而 [self xxx_viewWillAppear:animated];这个方法实际上调用的是系统的viewWillAppear。 这就证实了swizzling只是交换两个方法在函数表中的指向地址而已。 预防措施 在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。 避免冲突：为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。 理解实现原理： 只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 能够让你更好理解实现原理。 持续的预防： 不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。 #十.感想runtime是把双刃剑，因为所有的代码都运行在它之上，改变它，可能会改变代码的正常运行逻辑和所有与之交互的东西，因此会产生可怕的副作用。但同时它强大的功能也可以给应用的框架或者代码的编写带来非常大的遍历。 因此，对于runtime唯一的建议就是，需谨慎使用，一旦使用，必须先了解runtime的相关原理，做好预防措施。 #十一.最后:送上一张喜欢的图片: 这是一篇总结笔记，大家有兴趣可以蛮看一下，如果觉得不错，麻烦给个喜欢或star,若发现有错误的地方请及时反馈，谢谢！","tags":[{"name":"IOS","slug":"IOS","permalink":"//fjf.com/tags/IOS/"},{"name":"Runtime","slug":"Runtime","permalink":"//fjf.com/tags/Runtime/"},{"name":"黑魔法","slug":"黑魔法","permalink":"//fjf.com/tags/黑魔法/"},{"name":"Associated Objects","slug":"Associated-Objects","permalink":"//fjf.com/tags/Associated-Objects/"},{"name":"Method Swizzling","slug":"Method-Swizzling","permalink":"//fjf.com/tags/Method-Swizzling/"}]},{"title":"UINavigationBar和UITabBar 上滚渐变显示 下拉渐变隐藏","date":"2017-01-21T16:00:00.000Z","path":"2017/01/22/UINavigationBar和UITabBar 上滚渐变显示 下拉渐变隐藏/","text":"由于项目需求要做一个这样的功能，所以做好之后，抽取出来，封装了下，希望能帮到有需要的朋友。 一.效果图 UINavigationBar和UITabbar渐变.gif 二.思路 A. 设置tableView a.因为当UINavigationBar和UITabBar隐藏的时候，tableView要完全占据整个屏幕，当UINavigationBar和UITabBar显示的时候，tableView又要显示在UINavigationBar下方，所以需要设置tablewView的frame和contentInset： 123self.tableView.frame = CGRectMake(0, -kNavigationBarHeight,kScreenWidth,kScreenHeight+kNavigationBarHeight);self.tableView.contentInset = UIEdgeInsetsMake(kNavigationBarHeight,0,0,0); B.设置UINavigationBar和UITabBar的位移 当tableView向上移动一个属性,UINavigationBar要向上移动一个属性，UITabBar要向下移动一个像素，所以需要在- (void)scrollViewDidScroll:(UIScrollView*)scrollView方法中获取每一次tableView滚动的距离，因此需要记住上次tableView的偏移量距离： 12345678910111213141516CGFloat_originalOffsetY;//上一次偏移量CGFloat offsetY = scrollView.contentOffset.y-_originalOffsetY;//获取每次滚动偏移的距离 _originalOffsetY = scrollView.contentOffset.y;//将这次tableView偏移量重新赋值给_originalOffsetY ~~~ 又因为当UINavigationBar和UITabBar已经隐藏，继续向上滚动，已经不需要隐藏，同样的当tableView滚动到最后滚不动的时候UINavigationBar和UITabBar也不需要移动，所以添加判断条件~~~ //判断是否滚动到底部CGFloat bottomOffset = scrollView.contentSize.height - scrollView.contentOffset.y - scrollView.frame.size.height; //判断UINavigationBar是否已经隐藏scrollView.contentOffset.y &gt; - (2*kNavigationBarHeight) 12345678910111213// UIScrollView 代理- (void)scrollViewDidScroll:(UIScrollView*)scrollView &#123; CGFloat bottomOffset = scrollView.contentSize.height- scrollView.contentOffset.y- scrollView.frame.size.height; if(scrollView.contentOffset.y&gt; - kNavigationBarHeight &amp;&amp; bottomOffset &gt;0) &#123; CGFloat offsetY = scrollView.contentOffset.y-_originalOffsetY; [self moveNavigationBarAndStatusBarByOffsetY:offsetY]; &#125; _originalOffsetY= scrollView.contentOffset.y;&#125; C.设置UINavigationBar和UITabBar相关transform.ty moveNavigationBarAndStatusBarByOffsetY函数设置UINavigationBar和UITabBar相关transform.ty位置的值，同时设置相关背景图片的透明度 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 通过偏移量移动NavigationBar和StatusBar- (void)moveNavigationBarAndStatusBarByOffsetY:(CGFloat)offsetY &#123; CGFloat transformTy = self.navigationController.navigationBar.transform.ty; CGFloat tabbarTransformTy = self.tabBarController.tabBar.transform.ty; // 向上滚动 if (offsetY &gt; 0) &#123; if (fabs(transformTy) &gt;= kNavigationBarHeight) &#123; //当NavigationBar的transfrom.ty大于NavigationBar高度，导航栏离开可视范围，设置NavigationBar隐藏 [self setNavigationBarTransformProgress:1 navigationBarStatusType:NavigationBarStatusOfTypeHidden]; &#125; else &#123; //当NavigationBar的transfrom.ty小于NavigationBar高度，导航栏在可视范围内，设置NavigationBar偏移位置和背景透明度 [self setNavigationBarTransformProgress:offsetY navigationBarStatusType:NavigationBarStatusOfTypeNormal]; &#125; if (fabs(tabbarTransformTy) &gt;= kStatusBarHeight) &#123; //当StatusTabBar的transfrom.ty大于StatusTabBar高度，导航栏离开可视范围，设置StatusTabBar隐藏 [self setStatusBarTransformProgress:1 statusBarStatusType:StatusBarStatusTypeOfHidden]; &#125; else &#123; //当当StatusTabBar的transfrom.ty小于StatusTabBar高度，导航栏在可视范围内，设置StatusTabBar偏移位置和背景透明度 [self setStatusBarTransformProgress:offsetY statusBarStatusType:StatusBarStatusTypeOfNormal]; &#125; // 向下滚动 &#125; else if(offsetY &lt; 0)&#123; if (transformTy &lt; 0 &amp;&amp; fabs(transformTy) &lt;= kNavigationBarHeight) &#123; //当NavigationBar的transfrom.ty小于NavigationBar高度，导航栏进入可视范围内，设置NavigationBar偏移位置和背景透明度 [self setNavigationBarTransformProgress:offsetY navigationBarStatusType:NavigationBarStatusOfTypeNormal]; &#125; else &#123; //当NavigationBar的transfrom.ty超过NavigationBar原来位置，设置NavigationBar显示 [self setNavigationBarTransformProgress:0 navigationBarStatusType:NavigationBarStatusOfTypeShow]; &#125; if (tabbarTransformTy &lt;= kStatusBarHeight &amp;&amp; tabbarTransformTy &gt; 0) &#123; //当StatusTabBar的transfrom.ty小于StatusTabBar高度，导航栏进入可视范围内，设置StatusTabBar偏移位置和背景透明度 [self setStatusBarTransformProgress:offsetY statusBarStatusType:StatusBarStatusTypeOfNormal]; &#125; else &#123; //当StatusTabBar的transfrom.ty超过StatusTabBar原来位置，设置StatusTabBar显示 [self setStatusBarTransformProgress:0 statusBarStatusType:StatusBarStatusTypeOfShow]; &#125; &#125;&#125; D. UINavigationBar和UITabBar背景图透明度和颜色通过这两个函数来改变UINavigationBar和UITabBar背景图透明度和颜色: 12345678910111213141516171819// 根据传入的类型和渐变程度,改变StatusBar的颜色和位置- (void)setStatusBarTransformProgress:(CGFloat)progress statusBarStatusType: (StatusBarStatusType)statusBarStatusType&#123; CGFloat transfromTy = self.tabBarController.tabBar.transform.ty; if (statusBarStatusType == StatusBarStatusTypeOfHidden) &#123; if (transfromTy != kStatusBarHeight) &#123; [self.tabBarController.tabBar fj_moveByTranslationY:kStatusBarHeight * progress]; [self.tabBarController.tabBar fj_setImageViewAlpha:progress]; &#125; &#125;else if(statusBarStatusType == StatusBarStatusTypeOfNormal) &#123; [self.tabBarController.tabBar fj_setTranslationY:-progress]; CGFloat alpha = 1 - fabs(self.tabBarController.tabBar.transform.ty)/kStatusBarHeight; [self.tabBarController.tabBar fj_setImageViewAlpha:alpha]; &#125;else if(statusBarStatusType == StatusBarStatusTypeOfShow) &#123; if (transfromTy != 0) &#123; [self.tabBarController.tabBar fj_moveByTranslationY: -kStatusBarHeight * progress]; [self.tabBarController.tabBar fj_setImageViewAlpha:(1-progress)]; &#125; &#125;&#125; 12345678910111213141516171819// 根据传入的类型和渐变程度,改变NavigationBar的颜色和位置- (void)setNavigationBarTransformProgress:(CGFloat)progress navigationBarStatusType:(NavigationBarStatusType)navigationBarStatusType&#123; CGFloat transfromTy = self.navigationController.navigationBar.transform.ty; if (navigationBarStatusType == NavigationBarStatusOfTypeHidden) &#123; if(transfromTy != -kNavigationBarHeight)&#123; [self.navigationController.navigationBar fj_moveByTranslationY:-kNavigationBarHeight * progress]; [self.navigationController.navigationBar fj_setImageViewAlpha:progress]; &#125; &#125;else if(navigationBarStatusType == NavigationBarStatusOfTypeNormal) &#123; [self.navigationController.navigationBar fj_setTranslationY: - progress]; CGFloat alpha = 1 - fabs(self.navigationController.navigationBar.transform.ty)/kNavigationBarHeight; [self.navigationController.navigationBar fj_setImageViewAlpha:alpha]; &#125;else if(navigationBarStatusType == NavigationBarStatusOfTypeShow) &#123; if(transfromTy != 0)&#123; [self.navigationController.navigationBar fj_moveByTranslationY:-kNavigationBarHeight * progress]; [self.navigationController.navigationBar fj_setImageViewAlpha:(1-progress)]; &#125; &#125;&#125; E.设置UITabBar和UINavigationBar类方法 // 设置背景图透明度 - (void)fj_setImageViewAlpha:(CGFloat)alpha; // 根据translationY在原来位置上偏移 - (void)fj_setTranslationY:(CGFloat)translationY; // 设置偏移translationY - (void)fj_moveByTranslationY:(CGFloat)translationY; F.停止时刻处理 在- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate函数里面判断当前NavigationBar偏移是否超过一半，如果一半则动画隐藏，如果没有则动画显示: 1234567891011121314151617//恢复或隐藏navigationBar和statusBar- (void)restoreNavigationBarAndStatusBarWithContentOffset:(CGPoint)contentOffset &#123; CGFloat navigationBarCenterHeight = kNavigationBarHeight/2.0; CGFloat transformTy = self.navigationController.navigationBar.transform.ty; if (transformTy &lt; 0 &amp;&amp; transformTy &gt; -kNavigationBarHeight) &#123; if (transformTy &lt; -navigationBarCenterHeight &amp;&amp; contentOffset.y &gt; -navigationBarCenterHeight) &#123; [UIView animateWithDuration:kDefaultAnimationTime animations:^&#123; [self hideNavigationBarAndStatusBar]; &#125;]; &#125; else &#123; [UIView animateWithDuration:kDefaultAnimationTime animations:^&#123; [self showNavigationBarAndStatusBar]; &#125;]; &#125; &#125;&#125; 三.最后:送上我最喜欢之一的动漫图: 这是gitHub链接和简书地址，大家有兴趣可以看一下，如果觉得不错，麻烦给个喜欢或星，谢谢！","tags":[{"name":"IOS","slug":"IOS","permalink":"//fjf.com/tags/IOS/"},{"name":"动画","slug":"动画","permalink":"//fjf.com/tags/动画/"},{"name":"UINavigationBar","slug":"UINavigationBar","permalink":"//fjf.com/tags/UINavigationBar/"},{"name":"UITabBar","slug":"UITabBar","permalink":"//fjf.com/tags/UITabBar/"}]},{"title":"2016 总结","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/我的2016-年终总结/","text":"不知不觉间，2016已经走到年尾了。再过几天就是农历的除夕，粗略回想一下，真心觉得2016过得贼快，仿佛什么都没做，它就溜走了；但细细一想，其实，这一年里也发生了很多事情。而且，对于我来说很多都是大事。年底，稍微闲点，因此，总结下过往，寄语于新年。 一. 工作工作是这一整年的重心，来青柠互动也一年多了，作为初创公司的元老之一，这一年陪着公司一起成长，经历挺多，也学到挺多。 1. 工作能力 这一年来，基本都是跟着项目走，从1758广场舞到D.Talk再到D.OA,到最后一直担任D.Talk的项目负责人，负责D.Talk的迭代更新；几个项目锻炼下来，编程的思路、对于OC这么语言的理解、对于项目的掌控，以及bug的处理能力，总的来说，是有一定长足的进步。 挺感谢青柠给予的这个平台，让我可以比较完整的锻炼了，虽然其中包含了大量的加班，但能看到自己比较明显的进步，在这个快节奏的城市里，至少能有一点心安。 同时，比较空闲的时候，也自己开源了一些项目，写了一些技术博客，对于技术做了一些总结，也因为这样，认识了很多传说中的大牛，他们有的比自己还小，但是编程的功底明显比自己高很多，羡慕之余，也激发了自己的斗志。感觉这样挺踏实的。 2. 工作认知 2016，移动端的风，基本已经消散，飞起来的猪，很多头先着地了。寒冬已至，作为创业公司的青柠和IOS开发的我也一样受到了影响。 去年，创业初期的25名员工，到今年年底只剩12名老员工了，当然还有40几个新员工的加入。人来人走，在IT这一行业，是一种常态，也算见怪不怪了。 离职的员工里，有些是自己想走，有些是被公司开除的，看着熟悉的面孔的离别，我逐渐意识到，生存成为了公司也是我们这些开发者的目标。激烈竞争的市场为了生存或是以后的生活，公司不断优化着自己的最合理配置，程序员之间的优胜劣汰也逐步显现出来，尤其像现在IOS端人满为患。所以学习成为了我们第一要务。 学习不只是编程技能的提高，还包括着对于项目功能的理解和把控；对于app用户体验的敏锐直觉；对于市场动态的了解等，这方面我真的要感谢强哥，这一年里，他教会了我很多除了编程以外的东西，尤其是作为项目负责人的所必须的细心和用心。 3. 工作心得 这是挺幸运的一年，年会的时候，拿了最佳优秀员工，同时自己表演的节目也得了三等奖，(PS:去年是一等奖，今年选材没选好，拖累了鹏程和余红)，最后还中了128G的IPhone7。确实是挺幸运的，人生第一次中大奖，不过，光红包也发了2000多。但确实很感谢，大家的认可。 不觉间也毕业了2年多了，从福州到深圳，从鑫诺到爱高到青柠，对于工作，确实有太多不可变因素了，离开鑫诺是因为想来深圳，离开爱高，是因为风停了，公司倒了，衷心祝愿青柠会越来越好。 二. 生活这一年生活中最重要的就是完成了人生的两件大事。 1. 女朋友 作为一个单身20几年的青年，说实话，我一直都觉得24岁左右，我就应该会有女朋友了，后来力达，先有女朋友了，这更加增强了我的预感。 现在的女朋友是我高中好友的大学同学，是一起爬山的时候认识的。可能是因为兴趣爱好比较一致，后来就走到一起了。她和我兴趣爱好很像，都喜欢动漫、运动、看书，但是做事和生活方面则比较互补，我喜欢早起，她喜欢睡懒觉；我相对勤快，她相对较懒；我情商相对高点，而她智商相对高点；我做事喜欢规划，她做事比较随性。 不过我觉得这样也挺好的，关键是聊得来。 2. 房子 2016年另外最大的一件事，就是在厦门岛外翔安区买了一套120平左右的房子。 2015年末，看着深圳飞涨的房价，我就有预感，厦门也一定要涨了，但是2015年底，刚好要准备我妹妹的婚事，也没来得及跟爸妈商量。2016年初，厦门的房价上涨的趋势已经很明显了，所以岛内先点燃了，这是岛外也抬头了，我开始和爸妈合计，一开始找了一套二手房，定金付了，但是房东迟迟不交房，拖了一个多月。我开始觉得房东是看到房价上涨趋势不打算卖了，后来直接退了定金，买了首开的三期的房子。 我爸去问的时候，三期只剩下了2套房子，而且都是120平左右的高层，80到100的已经全部售罄，看着昨天从晚上2点排队到早上的长队，我开始觉得，厦门这一波房价的涨势估计要持续很久了。 有时候觉得人生真的挺悲剧的，加在深圳和厦门之间，房价分别全国第一和全国第四，看着最后剩下的2套房子，我开始纠结了，凑够了首付，接下来每个月的月供也足以压得我喘不过气来，这对于刚毕业不到两年的我来说，确实负担太大了；可是，如果这个时候，不下手，估计以后就再也没机会了。犹豫了一晚上，后来下定决心，买了。毕竟，有压力，才有动力。 从此以后我过上了房奴的生活，而且是扛着大山的房奴。开始j节制自己的花销。可现实往往不如自己所想。如果是以前自己一个人，那倒还好，可是谈恋爱，怎么可能有不花钱的呢？这一年来，其中的艰辛，不足为外人道。 如果有人问我:2016年，最深的体会是什么？ 我想我就回答两点: 1. 钱是好东西，真的是好东西。 2. 要努力提高自己赚钱的本领，然后一定要进行合理的理财规划。 三.规划1. 钻研技术 a. 对以往做过的项目，用到的知识进行总结，将一些模糊的点，理清楚。 b. 将收藏的博客和开源的项目进行相关阅读，并整理笔记，同时将自己项目中用到的一些好用的工具封装，开源，并维护好博客和开源的项目。 c. 将以前看过的算法相关的书籍的知识内容进行整理，然后将《剑指offer》、《编程之美》等相关书籍继续读完并整理笔记。 d. 将学到一半的安全知识继续学下去，然后跟志鹏学长一起研究和学习。 2. 照顾家人 a. 明年年初如果不出意外的话，我和女朋友就结婚了，虽然比预想的早了点，但确实有太多出乎意料的情况了，结婚了，在我们闽南就是成家了，就要学会担当了，要学着怎么去做好一个成年人了，我会尽力去做好的。 b. 明年也25了，对于未来，我也开始有点担忧了，之前一直觉得多学点，好好专研技术，就可以了。很多东西也没有很好去考虑，比如之后是回去厦门发展还是留着深圳；如果要回去，什么时候回去；回去之后的各种问题，比如工作薪水会不会差距很大，生活成本各个方面，对于这些我想趁着这个过年，应该静下心来好好想一想，听听家里和朋友的看法。 最后清风拂过，老了嫩叶，绿了季节！2016，真的成长了很多。难怪，最近我越来越喜欢喝茶了，原来真的初老了。 但愿，未来会更好，而我，会更加努力！","tags":[{"name":"总结","slug":"总结","permalink":"//fjf.com/tags/总结/"},{"name":"情感","slug":"情感","permalink":"//fjf.com/tags/情感/"}]}]